# -*- coding: utf-8 -*-
"""
    sphinx.writers.latex
    ~~~~~~~~~~~~~~~~~~~~

    Custom docutils writer for LaTeX.

    Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
    docutils sandbox.

    :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""

import re
import sys
import string
from os import path

from docutils import nodes, writers
from docutils.writers.latex2e import Babel

from sphinx import addnodes
from sphinx import highlighting
from sphinx.errors import SphinxError
from sphinx.locale import admonitionlabels, versionlabels, _
from sphinx.util.osutil import ustrftime
from sphinx.util.pycompat import any
from sphinx.util.texescape import tex_escape_map, tex_replace_map
from sphinx.util.smartypants import educate_quotes_latex

do_in_this_collection = False

xmoslatex_admonitionlabels = { 'attention' : 'attention',
                               'caution' : 'attention',
                               'danger' : 'danger',
                               'error' : 'danger',
                               'hint' : 'tip',
                               'important' : 'info',
                               'info' : 'info',
                               'note' : 'info',
                               'tip' : 'tip',
                               'warning' : 'attention',
                               'newinxc' : 'newinxc'}


NON_XMOS_HEADER = r'''\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 

\usepackage{xdoc}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\usepackage{color}
\definecolor{lightgrey}{gray}{0.93}
\usepackage{ragged2e}
\usepackage{ifsym}
\renewcommand\thesection{\arabic{section}} 
%% Set inner and outer margins to .5 and 1 inch, respectively
\setlrmarginsandblock{1in}{1in}{*}
%% Set top and bottom margins to .8 inches
\setulmarginsandblock{.8in}{.8in}{*}
\checkandfixthelayout
\setlength{\parindent}{0cm}
\addtolength{\parskip}{0.2\baselineskip}
'''


HEADER0 = r'''%% Generated by Sphinx.
\def\sphinxdocclass[english]{%(docclass)s}
\documentclass[%(pointsize)s %(classopts)s %(doctype)s]{%(wrapperclass)s}
%(inputenc)s
%(utf8extra)s
'''

HEADER1 = r'''
%(longtable)s

%(preamble)s

\title{%(title)s}
\date{%(date)s}
\author{%(author)s}
\newcommand{\sphinxlogo}{%(logo)s}
\newcommand{\releasename}{%(releasename)s}
\usepackage{xsphinx}
\usepackage{threeparttable}
\usepackage{fancyvrb}
\usepackage{indent}
\renewcommand\bfcode\textbf
\renewcommand\bf\textbf
\graphicspath{{./}{./images/}}
%(makeindex)s
'''

BEGIN_DOC = r'''
\setlength{\emergencystretch}{8em}
%(begin)s
%(shorthandoff)s
%(maketitle)s
%(fullwidth)s
'''

FOOTER = r'''
%(toc)s
%(enddoc)s
'''

toplevel_desc = ['function','type','macro']


class collected_footnote(nodes.footnote):
    """Footnotes that are collected are assigned this class."""


class UnsupportedError(SphinxError):
    category = 'Markup is unsupported in LaTeX'


class XLaTeXWriter(writers.Writer):

    supported = ('sphinxlatex',)

    settings_spec = ('LaTeX writer options', '', (
        ('Document name', ['--docname'], {'default': ''}),
        ('Document class', ['--docclass'], {'default': 'collection'}),
        ('Author', ['--author'], {'default': ''}),
        ))
    settings_defaults = {}

    output = None

    def __init__(self, builder):
        writers.Writer.__init__(self)
        self.builder = builder

    def translate(self):
        visitor = LaTeXTranslator(self.document, self.builder)
        self.document.walkabout(visitor)
        self.output = visitor.astext()


# Helper classes
class ExtBabel(Babel):
    def get_shorthandoff(self):
        shortlang = self.language.split('_')[0]
        if shortlang in ('de', 'sl', 'pt', 'es', 'nl', 'pl', 'it'):
            return '\\shorthandoff{"}'
        return ''

    #_ISO639_TO_BABEL = Babel._ISO639_TO_BABEL.copy()
    #ma_ISO639_TO_BABEL['sl'] = 'slovene'


class Table(object):
    def __init__(self):
        self.col = 0
        self.colcount = 0
        self.colspec = []
        self.rowcount = 0
        self.had_head = False
        self.has_verbatim = False
        self.caption = None
        self.longtable = False
        self.prev_colcount = None



class LaTeXTranslator(nodes.NodeVisitor):
    sectionnames = ["chapter", "section", "subsection",
                    "subsubsection", "paragraph", "subparagraph"]

    ignore_missing_images = False

    default_elements = {
        'papersize':       'letterpaper',
        'pointsize':       '12pt',
        'classoptions':    '',
        'inputenc':        '\\usepackage[utf8]{inputenc}',
        'utf8extra':       '\\DeclareUnicodeCharacter{00A0}{\\nobreakspace}',
        'fontenc':         '\\usepackage[T1]{fontenc}',
        'babel':           '\\usepackage{babel}',
        'fontpkg':         '\\usepackage{times}',
        'fncychap':        '\\usepackage[Bjarne]{fncychap}',
        'longtable':       '\\usepackage{longtable}',
        'preamble':        '',
        'title':           '',
        'date':            '',
        'release':         '',
        'author':          '',
        'logo':            '',
        'releasename':     'Release',
        'makeindex':       '\\makeindex',
        'shorthandoff':    '',
        'maketitle':       '\\maketitle',
        'tableofcontents': '\\tableofcontents',
        'footer':          '',
        'printindex':      '\\printindex',
        'toc':'',
        'fullwidth':'',
    }

    def __init__(self, document, builder):
        nodes.NodeVisitor.__init__(self, document)
        self.builder = builder
        self.body = []

        # sort out some elements
        papersize = builder.config.latex_paper_size + 'paper'
        if papersize == 'paper': # e.g. command line "-D latex_paper_size="
            papersize = 'letterpaper'

        self.elements = self.default_elements.copy()
        if self.builder.config.latex_toc:
            toc = '\\posttoc\n'
        else:
            toc = ''

        if self.builder.config.latex_doctype == 'collection':
            first_title = document.traverse(nodes.title)[0]
            title_index = first_title.parent.index(first_title)
            next = first_title.parent[title_index+1]
            self.has_preface = \
                  not isinstance(next,nodes.substitution_definition)
        else:
            self.has_preface = False


        if self.has_preface:
            fullwidth = '\\clearpage\n\\begin{fullwidth} %preface\n{\\small\\textls{\\textsf{SYNOPSIS}}}'
        else:
            fullwidth = '\\pretoc'

        begin = '\\start'
        enddoc = '\\finish'

        self.seen_first_title = False
        self.elements.update({
            'wrapperclass': builder.config.latex_docclass,
            'doctype': builder.config.latex_doctype,
            'papersize':    papersize,
            'pointsize':    builder.config.latex_font_size ,
            # if empty, the title is set to the first section title
            'title':        document.settings.title,
            'release':      builder.config.release,
            'author':       document.settings.author,
            'releasename':  _('Release'),
            'preamble':     builder.config.latex_preamble,
            'toc' : toc,
            'fullwidth': fullwidth,
            'indexname':    _('Index'),
            'begin':begin,
            'enddoc':enddoc
        })

        self.elements['classopts'] = ''

        document.settings.docclass = builder.config.latex_docclass

        # if document.settings.docclass == 'howto':
        #     docclass = builder.config.latex_docclass.get('howto', 'article')
        # else:
        #     docclass = builder.config.latex_docclass.get('collection', 'report')
        
        self.elements['docclass'] = builder.config.latex_docclass

        if builder.config.today:
            self.elements['date'] = builder.config.today
        else:
            self.elements['date'] = ustrftime(builder.config.today_fmt
                                              or _('%B %d, %Y'))
        if builder.config.latex_logo:
            self.elements['logo'] = '\\includegraphics{%s}\\par' % \
                                    path.basename(builder.config.latex_logo)
        if builder.config.language:
            babel = ExtBabel(builder.config.language)
            lang = babel.get_language()
            if lang:
                self.elements['classoptions'] += ',' + babel.get_language()
            else:
                self.builder.warn('no Babel option known for language %r' %
                                  builder.config.language)
            self.elements['shorthandoff'] = babel.get_shorthandoff()
            self.elements['fncychap'] = '\\usepackage[Sonny]{fncychap}'
        else:
            self.elements['classoptions'] += ',english'
        # allow the user to override them all
        self.elements.update(builder.config.latex_elements)

        self.highlighter = highlighting.PygmentsBridge('latex',
            builder.config.pygments_style, builder.config.trim_doctest_flags)
        self.context = []
        self.descstack = []
        self.bibitems = []
        self.table = None
        self.next_table_colspec = None
        self.next_table_tabularcolumns = None
        # stack of [language, linenothreshold] settings per file
        # the first item here is the default and must not be changed
        # the second item is the default for the master file and can be changed
        # by .. highlight:: directive in the master file
        self.hlsettingstack = 2 * [[builder.config.highlight_language,
                                    sys.maxint]]
        self.footnotestack = []
        self.curfilestack = []
        self.in_footnote = False
        self.handled_abbrs = set()

        if document.settings.docclass == 'howto':
            self.top_sectionlevel = 2
        else:
            if builder.config.latex_use_parts:
                self.top_sectionlevel = 0
            elif builder.config.latex_use_chapters:
                self.top_sectionlevel = 0
            else:
                self.top_sectionlevel = 1
        self.next_section_ids = set()
        self.next_figure_ids = set()
        self.next_table_ids = set()
        # flags
        self.verbatim = None
        self.in_title = 0
        self.in_production_list = 0
        self.first_document = 1
        self.this_is_the_title = 1
        self.literal_whitespace = 0
        self.no_contractions = 0
        self.compact_list = 0
        self.first_param = 0
        self.fullwidth = False
        self.in_reference = False
        self.next_title_indent = False
        self.next_title_fullwidth = False
        self.section_summary_fullwidth = False
        self.in_subscript = False
        self.in_sig = False
        self.in_term = False
        self.in_strong = False
        self.in_tt = False
        self.section_summary_pos = None
        self.not_fullwidth = False
        self.part = None
        self.in_options = False
        self.in_cmd = False
        self.in_list_item = False

    def astext(self):
        text = HEADER0 % self.elements
        text = text + HEADER1 % self.elements
        text = text + self.highlighter.get_stylesheet() + \
                u''.join(self.body) + \
                '\n' + self.elements['footer'] + '\n' + \
                self.generate_indices() + \
                FOOTER % self.elements
        return text

    def hypertarget(self, id, withdoc=True, anchor=True):
        if withdoc:
            id = self.curfilestack[-1] + ':' + id
        return (anchor and '\\phantomsection' or '') + \
               '\\label{%s}' % self.idescape(id)

    def hyperlink(self, node, id):
#        self.no_emph = 1
#        print node['reftitle']

        if 'xmosreftype' in node:
            typ = node['xmosreftype']
            if typ in ['section','option']:
                if 'refexplicit' in node and node['refexplicit']:
                    pre = ''
                    post = ' (see~\Sec~\\ref{%s})' % (self.idescape(id))
                    return False, pre, post
                else:
                    return True, '\Sec~\\ref{%s}' % (self.idescape(id)),''
            if typ == 'figure':
                if 'refexplicit' in node and node['refexplicit']:
                    pre = ''
                    post = ' (see~Figure~\\ref{%s})' % (self.idescape(id))
                    return False, pre, post
                else:
                    return True, 'Figure~\\ref{%s}' % (self.idescape(id)),''

        m = re.match('.*doc:[xX]?[mM]?(\d*)(.*)',id)
        if m:
            docnum = m.groups(0)[0]
            rest= m.groups(0)[1]
            url = 'http://www.xmos.com/docnum/X%s%s' % (docnum,rest)
            if self.in_footnote:
                url = url.replace('#','\\#')
            if 'refexplicit' in node and node['refexplicit']:
                pre = ''
                post = ' (see~\\href{%s}{X%s})' % (url,docnum)
                return False, pre, post
            else:
                pre = '\\href{%s}{X%s}' % (url,docnum)
                return True, pre, ''

        m = re.match('.*part:(.*):(.*)',id)
        if m:
            docnum = m.groups(0)[0]
            rest = m.groups(0)[1]
            url = 'http://www.xmos.com/doc/%s/latest%s' % (docnum,rest)
            if self.in_footnote:
                url = url.replace('#','\\#')
            if 'refexplicit' in node and node['refexplicit']:
                pre = ''
                post = ' (see~\\href{%s}{%s})' % (url,docnum)
                return False, pre, post
            else:
                pre = '\\href{%s}{%s}' % (url,docnum)
                return True, pre, ''

        pre = '{\\hyperref[%s]{' % (self.idescape(id))
        post = '}}'
        return False, pre, post

    def hyperpageref(self, id):
        return '\\autopageref*{%s}' % (self.idescape(id))

    def idescape(self, id):
        return str(unicode(id).translate(tex_replace_map))

    def generate_indices(self):
        def generate(content, collapsed):
            ret.append('\\begin{theindex}\n')
            ret.append('\\def\\bigletter#1{{\\Large\\sffamily#1}'
                       '\\nopagebreak\\vspace{1mm}}\n')
            for i, (letter, entries) in enumerate(content):
                if i > 0:
                    ret.append('\\indexspace\n')
                ret.append('\\bigletter{%s}\n' %
                           letter.translate(tex_escape_map))
                for entry in entries:
                    if not entry[3]:
                        continue
                    ret.append('\\item \\texttt{%s}' % self.encode(entry[0]))
                    if entry[4]:
                        # add "extra" info
                        ret.append(' \\emph{(%s)}' % self.encode(entry[4]))
                    ret.append(', \\pageref{%s:%s}\n' %
                               (entry[2], self.idescape(entry[3])))
            ret.append('\\end{theindex}\n')

        ret = []
        # latex_domain_indices can be False/True or a list of index names
        indices_config = self.builder.config.latex_domain_indices
        if indices_config:
            for domain in self.builder.env.domains.itervalues():
                for indexcls in domain.indices:
                    indexname = '%s-%s' % (domain.name, indexcls.name)
                    if isinstance(indices_config, list):
                        if indexname not in indices_config:
                            continue
                    # deprecated config value
                    if indexname == 'py-modindex' and \
                           not self.builder.config.latex_use_modindex:
                        continue
                    content, collapsed = indexcls(domain).generate(
                        self.builder.docnames)
                    if not content:
                        continue
                    ret.append(u'\\renewcommand{\\indexname}{%s}\n' %
                               indexcls.localname)
                    generate(content, collapsed)

        return ''.join(ret)

    def visit_document(self, node):
        self.footnotestack.append(self.collect_footnotes(node))
        self.curfilestack.append(node.get('docname', ''))
        if self.first_document == 1:
            # the first document is all the regular content ...
            self.body.append(BEGIN_DOC % self.elements)
            self.first_document = 0
        elif self.first_document == 0:
            # ... and all others are the appendices
            self.body.append(u'\n\\appendix\n')
            self.first_document = -1
        if node.has_key('docname'):
            self.body.append(self.hypertarget(':doc'))
        # "- 1" because the level is increased before the title is visited
        self.sectionlevel = self.top_sectionlevel - 1
        self.section_summary = []

        if self.builder.config.latex_doctype == 'collection':
            #print >>sys.stderr,"DEBUG"
            self.has_parts = False
            for sof in node.traverse(addnodes.start_of_file):
                try:
                    self.builder.env.partmap[sof['docname']]
                    self.has_parts = True
                except:
                    pass

            self.parts = []

            current_part = None
            current_chapters = []
            for sof in node.traverse(addnodes.start_of_file):
                container = sof.parent.parent.parent
                master_doc = self.builder.config.master_doc
                if 'docname' in container and container['docname'] == master_doc:
                    sections = sof.traverse(nodes.section)
                    if not sections:
                        continue

                    sec = sections[0]
                    ids = [id for id in sec['ids'] if id != '']
                    id = sof['docname']+':'+ids[0]
                    if self.has_parts:
                        try:
                            new_part = self.builder.env.partmap[sof['docname']]
                            if new_part:
                                if current_part:
                                    self.parts.append((current_part,
                                                       current_chapters))
                                current_part = new_part
                                current_chapters = []
                        except:
                            pass

                        current_chapters.append(id)
                    else:
                        self.parts.append(id)

            if self.has_parts:
                self.parts.append((current_part, current_chapters))

        for p in node.traverse(nodes.paragraph):
            p['margin_items'] = []

        if self.builder.config.do_section_summary:
            self.section_summary_pos = len(self.body)+1

    def depart_document(self, node):

        summary = '%last summary\n'
        if self.section_summary != []:
            summary += "\\begin{inthisdocument}\n"
            for item in self.section_summary:
                summary += "\item %s\n"%item
            summary += "\\end{inthisdocument}\n\n"

        if self.section_summary_fullwidth:
            summary += '\\begin{fullwidth} % chapter!!\n'

        if self.builder.config.do_section_summary:
            self.body.insert(self.section_summary_pos, summary)

        if self.builder.config.latex_doctype == 'collection':
            self.end_preface()

        if False and self.bibitems:
            widest_label = ""
            for bi in self.bibitems:
                if len(widest_label) < len(bi[0]):
                    widest_label = bi[0]
            self.body.append(u'\n\\begin{thebibliography}{%s}\n' % widest_label)
            for bi in self.bibitems:
                target = self.hypertarget(bi[2] + ':' + bi[0].lower(),
                                          withdoc=False)
                self.body.append(u'\\bibitem[%s]{%s}{%s %s}\n' %
                    (bi[0], self.idescape(bi[0]), target, bi[1]))
            self.body.append(u'\\end{thebibliography}\n')
            self.bibitems = []

    def visit_start_of_file(self, node):
        try:
            self.part = self.builder.env.partmap[node['docname']]
        except:
            self.part = None

        # collect new footnotes
        self.footnotestack.append(self.collect_footnotes(node))
        # also add a document target
        self.next_section_ids.add(':doc')
        self.curfilestack.append(node['docname'])
        # use default highlight settings for new file
        self.hlsettingstack.append(self.hlsettingstack[0])

    def collect_footnotes(self, node):
        fnotes = {}
        def footnotes_under(n):
            if isinstance(n, nodes.footnote):
                yield n
            else:
                for c in n.children:
                    if isinstance(c, addnodes.start_of_file):
                        continue
                    for k in footnotes_under(c):
                        yield k
        for fn in footnotes_under(node):
            num = fn.children[0].astext().strip()
            fnotes[num] = [collected_footnote(*fn.children), False]
        return fnotes

    def depart_start_of_file(self, node):
        self.footnotestack.pop()
        self.curfilestack.pop()
        self.hlsettingstack.pop()

    def visit_highlightlang(self, node):
        self.hlsettingstack[-1] = [node['lang'], node['linenothreshold']]
        raise nodes.SkipNode

    def visit_section(self, node):
        if 'xc-spec' in node['classes']:
            self.body.append('\\begin{spec}')
        if not self.this_is_the_title:
            self.sectionlevel += 1
        self.body.append('\n\n')
        if node.get('ids'):
            self.next_section_ids.update(node['ids'])
        if 'testplan_item' in node['classes']:
            self.next_title_indent = True

        if 'not-fullwidth' in node['classes']:
            self.not_fullwidth = True
            self.prev_section_summary_fullwidth = self.section_summary_fullwidth
            self.section_summary_fullwidth = False

        if not self.fullwidth and not self.not_fullwidth:
          if self.builder.config.latex_doctype != 'collection' or self.sectionlevel == self.top_sectionlevel:
            self.prev_section_summary_fullwidth = self.section_summary_fullwidth
            self.section_summary_fullwidth = False
            for n in node.traverse():
                has_toplevel_desc = \
                    isinstance(n, addnodes.desc) and \
                    (n['desctype'] in toplevel_desc)
                tp_item = isinstance(n, nodes.section) and \
                    'testplan_item' in n['classes']
                if not 'not-fullwidth' in node['classes']:
                  if (has_toplevel_desc or
                      tp_item or
                      'fullwidth' in node['classes']):
                    self.fullwidth = True
                    if self.builder.config.do_section_summary:
                        self.section_summary_fullwidth = True
#                        self.body.append('\\begin{fullwidth} % fragment')
                        self.body.append('\n% FULLWIDTH SECTION (with summary)\n')
                    else:
                        self.body.append('\n% FULLWIDTH SECTION\n')
                    node['started_fullwidth'] = True
                    break

          if (self.builder.config.do_section_summary and
            not self.section_summary_fullwidth):
            self.body.append('\n% NON-FULLWIDTH SECTION\n')

    def depart_section(self, node):
        self.sectionlevel = max(self.sectionlevel - 1,
                                self.top_sectionlevel - 1)


        if 'testplan_item' in node['classes']:
            self.body.append('\\end{indentation}')
        if 'started_fullwidth' in node and node['started_fullwidth']:
            self.body.append('\\end{fullwidth}%')
            self.fullwidth = False
        if 'xc-spec' in node['classes']:
            self.body.append('\\end{spec}')

        if 'not-fullwidth' in node['classes']:
            self.not_fullwidth = False

    def visit_problematic(self, node):
        self.body.append(r'{\color{red}\bfseries{}')

    def depart_problematic(self, node):
        self.body.append('}')

    def visit_topic(self, node):
        self.body.append('\\setbox0\\vbox{\n'
                         '\\begin{minipage}{0.95\\linewidth}\n')
    def depart_topic(self, node):
        self.body.append('\\end{minipage}}\n'
                         '\\begin{center}\\setlength{\\fboxsep}{5pt}'
                         '\\shadowbox{\\box0}\\end{center}\n')
    visit_sidebar = visit_topic
    depart_sidebar = depart_topic

    def visit_glossary(self, node):
        pass

    def depart_glossary(self, node):
        pass

    def visit_productionlist(self, node):
        self.body.append('\n\n\\begin{productionlist}\n')
        self.in_production_list = 1

    def depart_productionlist(self, node):
        self.body.append('\\end{productionlist}\n\n')
        self.in_production_list = 0

    def visit_production(self, node):
        if node['tokenname']:
            self.body.append('\\production{%s}{' %
                             self.encode(node['tokenname']))
        else:
            self.body.append('\\productioncont{')
                
    def depart_production(self, node):
        self.body.append('}\n')

    def visit_transition(self, node):
        self.body.append('\n\n\\bigskip\\hrule{}\\bigskip\n\n')

    def depart_transition(self, node):
        pass

    def end_preface(self):
        if not self.seen_first_title:
            self.seen_first_title = True
            if self.has_preface:
                self.body.append('\\end{fullwidth}\n\\pretoc\n')
            if do_in_this_collection and self.parts != []:
                self.body.append('\\begin{inthiscollection}\n')
                if self.has_parts:
                    parts = ['\\hyperref[part:%s]{%s}'%(x,x) for (x,y) in self.parts]
                else:
                    parts = ['\\nameref{%s}'%x for x in self.parts]
                for p in parts:
                    self.body.append('\\item %s\n'%p)
                self.body.append('\\end{inthiscollection}\n')

    def output_part_index(self, part):
        chaps = None
        for (p,cs) in self.parts:
            if p==part:
                chaps = cs
        if chaps:
            self.body.append('\\begin{inthispart}\n')
            parts = ['\\nameref{%s}'%x for x in chaps]
            for p in parts:
                self.body.append('\\item %s\n'%p)
            self.body.append('\\end{inthispart}\n')

    def visit_title(self, node):
        parent = node.parent

        if isinstance(parent, addnodes.seealso):
            # the environment already handles this
            raise nodes.SkipNode
        elif self.this_is_the_title:
            if len(node.children) != 1 and not isinstance(node.children[0],
                                                          nodes.Text):
                self.builder.warn(
                    'document title is not a single Text node',
                    '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                               node.line or ''))
            if not self.elements['title']:
                # text needs to be escaped since it is inserted into
                # the output literally
                self.elements['title'] = node.astext().translate(tex_escape_map)
            self.this_is_the_title = 0
            raise nodes.SkipNode
        elif isinstance(parent, nodes.section):
            if not self.builder.config.latex_section_numbers or \
               'nosecnum' in node['classes']:
                modifier = '*'
            else:
                modifier = ''
            try:
                if self.builder.config.latex_doctype == 'collection':
                    self.end_preface()


                if self.sectionlevel == self.top_sectionlevel:
                    if self.part:
                        self.body.append('\n\\part{%s}\n\\label{part:%s}\n'%(self.part,self.part))
                        self.output_part_index(self.part)
                        self.body.append('\\clearemptydoublepage\n')
                        self.part = None


                if (self.builder.config.latex_section_newpage):
                    if (self.sectionlevel <= self.top_sectionlevel):
                        self.body.append('\\clearpage\n');
                if 'compact' in node['classes']:
                    self.body.append('\n\\vspace{-\\parsep}\n')

                self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel],modifier))
            except IndexError:
                indent = ""
                for i in range(1 + self.sectionlevel - len(self.sectionnames)):
                    indent += "\ \ "
                # just use "subparagraph", it's not nu mbered anyway

                if self.builder.config.latex_doctype == 'collection' and \
                        self.sectionlevel == self.top_sectionlevel:
                    if self.part:
                        self.body.append('\n\\part{%s}\n\\clearemptydoublepage\n'%self.part)
                        self.part = None

                self.body.append(r'\%s%s{' % (self.sectionnames[-1],modifier))
                self.body.append(indent)
            self.context.append('}\n')

            node['ids'] = self.next_section_ids.copy()
            if self.next_section_ids:
                for id in self.next_section_ids:
                    self.context[-1] += self.hypertarget(id, anchor=False)
                self.next_section_ids.clear()

        elif isinstance(parent, (nodes.topic, nodes.sidebar)):
            self.body.append(r'\textbf{')
            self.context.append('}\n\n\medskip\n\n')
        elif isinstance(parent, nodes.Admonition):
            self.body.append('\\textbf{')
            self.context.append('}\n')
        elif isinstance(parent, nodes.table):
            self._caption_saved_body = self.body
            self.body = []
            self.in_title = True
            return
        else:
            self.builder.warn(
                'encountered title node not in section, topic, table, '
                'admonition or sidebar',
                '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                           node.line or ''))
            self.body.append('\\textbf{')
            self.context.append('}\n')
        self.in_title = 1

        if self.builder.config.latex_doctype == 'collection':
            tp = self.top_sectionlevel
        else:
            tp = self.top_sectionlevel - 1
        if self.builder.config.do_section_summary and \
           self.sectionlevel == tp:

            summary = '%summary!\n'
            if self.section_summary != []:
                summary += "\\begin{inthisdocument}\n"
                for item in self.section_summary:
                    summary += "\item %s\n"%item
                summary += "\\end{inthisdocument}\n\n"

            if self.prev_section_summary_fullwidth:
                summary += '\\begin{fullwidth} % chapter!\n'

            if self.section_summary_pos:
                self.body.insert(self.section_summary_pos, summary)
            self.section_summary = []
            #self.section_summary_fullwidth = self.fullwidth

            self.section_summary_pos = len(self.body)+2
        if self.sectionlevel == tp+1:
            self.section_summary_entry_pos = len(self.body)
            #self.section_summary.append(str(node[0]))

    def depart_title(self, node):
        if isinstance(node.parent, nodes.table):
            self.table.caption = ''.join(self.body)
            self.body = self._caption_saved_body
            self.in_title = False
            return

        if self.builder.config.latex_doctype == 'collection':
            tp = self.top_sectionlevel + 1
        else:
            tp = self.top_sectionlevel
        if self.sectionlevel == tp:
            item = ''
            valid_ids = [x for x in node['ids'] if x != '']
            if valid_ids != []:
                id = self.curfilestack[-1] + ':' + valid_ids[0]
                item = '\\nameref{%s}' % id

            if self.builder.config.do_section_summary:
                self.section_summary.append(item)

        self.in_title = 0
        self.body.append(self.context.pop())
        if 'compact' in node['classes']:
            self.body.append('\n\\vspace{-\\parsep}\n')
        if self.next_title_indent:
            self.next_title_indent = False
            self.body.append('\\begin{indentation}{\\blockindentlen}{0mm}%%')

    def visit_subtitle(self, node):
        if isinstance(node.parent, nodes.sidebar):
            self.body.append('~\\\\\n\\textbf{')
            self.context.append('}\n\\smallskip\n')
        else:
            self.context.append('')

    def depart_subtitle(self, node):
        self.body.append(self.context.pop())

    def visit_desc_list(self, node):
        desctype = None
        for x in node.traverse(addnodes.desc):
            desctype = x['desctype']
            break
        node['desctype'] = desctype
        if desctype in toplevel_desc:
            pass
        elif desctype != None:
            self.body.append('\\begin{option}\n\n')
            self.body.append('\\addtolength{\\codeindent}{22mm}')
            self.in_options = True
        else:
            pass
#                print node

    def depart_desc_list(self, node):
        desctype = node['desctype']
        if desctype in toplevel_desc:
            pass
        elif desctype != None:
            self.body.append('\\addtolength{\\codeindent}{-22mm}')
            self.body.append('\\end{option}\n\n')
            self.in_options = False

    def visit_desc(self, node):
        if node['desctype'] in toplevel_desc:
            estimated_param_len = 0
            for y in node.traverse(addnodes.desc_signature):
                for x in y.traverse(nodes.Text):
                    estimated_param_len += len(str(x))
            if self.fullwidth:
                long_params = estimated_param_len > 70
            else:
                long_params = estimated_param_len > 65
            node['long_params'] = long_params
            for x in node.traverse(addnodes.desc_parameter):
                x['long_params'] = long_params
            if long_params:
                self.body.append('\n\\vspace{-1.5\\baselineskip}')
            self.body.append('\n\n\\texttt{')
            if long_params:
                self.body.append('\\begin{tabbing}')

    def depart_desc(self, node):
        pass

    def visit_desc_signature(self, node):
        node['desctype'] = node.parent['desctype']
        if node.parent['objtype'] != 'describe' and node['ids']:
            hyper = self.hypertarget(node['ids'][0])
        else:
            hyper = ''
        self.body.append(hyper)
        self.prev_duplicate_sig = False
        if not node.parent['desctype'] in toplevel_desc:
             self.body.append('\\item[')
        self.in_sig = True

    def depart_desc_signature(self, node):
        if not node.parent['desctype'] in toplevel_desc:
           self.body.append(r']')
           if self.prev_duplicate_sig:
               self.body.append('\duplicateoption')
        self.in_sig = False

    def visit_desc_addname(self, node):
        self.body.append(r'\optemph{')
        self.literal_whitespace += 1

    def depart_desc_addname(self, node):
        self.body.append('}')
        self.literal_whitespace -= 1

    def visit_desc_type(self, node):
        pass
    def depart_desc_type(self, node):
        pass

    def visit_desc_returns(self, node):
        self.body.append(r'}{ $\rightarrow$ ')
    def depart_desc_returns(self, node):
        pass

    def visit_desc_name(self, node):
       if 'duplicate' in node['classes']:
           if not node.parent['desctype'] in toplevel_desc:
               self.body.append(" ]")
               if self.prev_duplicate_sig:
                   self.body.append('\duplicateoption')
               self.body.append("\n\\item[")
               self.prev_duplicate_sig = True
       self.literal_whitespace += 1

    def depart_desc_name(self, node):
        self.literal_whitespace -= 1

    def visit_desc_parameterlist(self, node):
        self.body.append('(')
        self.first_param = 1
    def depart_desc_parameterlist(self, node):
        self.body.append(')')

    def visit_desc_parameter(self, node):
        if not self.first_param:
            if 'long_params' in node and node['long_params']:
                self.body.append(',\\\\ \n\\> ')
            else:
                self.body.append(', ')
        else:
            if 'long_params' in node and node['long_params']:
                self.body.append('\\= ')
            self.first_param = 0

    def depart_desc_parameter(self, node):
        pass

    def visit_desc_optional(self, node):
        self.body.append(r'\optional{')
    def depart_desc_optional(self, node):
        self.body.append('}')

    def visit_desc_annotation(self, node):
        self.body.append(r'\strong{')
    def depart_desc_annotation(self, node):
        self.body.append('}')

    def visit_desc_content(self, node):
       if node.parent['desctype'] in toplevel_desc:
           if node.parent['long_params']:
               self.body.append('\n\\end{tabbing}')
               if len(node.children) == 0:
                   self.body.append('\\vspace{-3mm}\n')

           if self.fullwidth:
               indent = '\\blockindentlen'
           else:
               indent = '\\blockindentlen'
           self.body.append('}\n\n')

           self.body.append('\\vspace{-2mm}\n')
           self.body.append('\\sloppy\n')
           if len(node.children) != 0:
               self.body.append('\\begin{indentation*}{%s}{0mm}'%indent)
           else:
               for x in node.parent.traverse(
                   condition=lambda x: not isinstance(x, addnodes.index),
                   include_self=False,
                   descend=False,
                   ascend=False,
                   siblings=True):
                   if isinstance(x, addnodes.desc):
                       # immediately followed by another desc
                       self.body.append('\n\\vspace{-0.25\\baselineskip}\n')
                   break

    def depart_desc_content(self, node):
       if node.parent['desctype'] in toplevel_desc:
           if len(node.children) != 0:
               self.body.append('\n\\end{indentation*}\n')
               #self.body.append('\\vspace{u3mm}\n')
           self.body.append('\\fussy\n')

    def visit_refcount(self, node):
        self.body.append("\\emph{")
    def depart_refcount(self, node):
        self.body.append("}\\\\")

    def visit_seealso(self, node):
        self.body.append(u'\n\n\\strong{%s:}\n\n' % admonitionlabels['seealso'])
    def depart_seealso(self, node):
        self.body.append("\n\n")

    def visit_rubric(self, node):
        if len(node.children) == 1 and node.children[0].astext() in \
               ('Footnotes', _('Footnotes')):
            raise nodes.SkipNode
        self.body.append('\\paragraph*{')
        self.context.append('}\n')
    def depart_rubric(self, node):
        self.body.append(self.context.pop())

    def visit_footnote(self, node):
        raise nodes.SkipNode

    def visit_collected_footnote(self, node):
        self.in_footnote = True
        self.body[-1] = self.body[-1].rstrip()
        self.body.append('\\footnote{')
    def depart_collected_footnote(self, node):
        self.in_footnote = False
        self.body.append('}')

    def visit_label(self, node):
        if isinstance(node.parent, nodes.citation):
            self.bibitems[-1][0] = node.astext()
            self.bibitems[-1][2] = self.curfilestack[-1]
#            print self.bibitems[-1][1]
            target = self.hypertarget(self.curfilestack[-1] + ':' + node.astext(),
                                      withdoc=False)
#        raise nodes.SkipNode

    def depart_label(self, node):
        pass

    def visit_tabular_col_spec(self, node):
        self.next_table_tabularcolumns = node['spec']
        raise nodes.SkipNode

    def visit_table(self, node):

        if 'raw' in node['classes']:
            self.body.append('%Raw Table\n')
            self.table = Table()
            self._body = self.body
            self.tablebody=[]
            self.body = self.tablebody
            self.table.longtable = False
            self.table.caption = node['caption']
            self.table.smaller = False
            self.table.bigger = True
            self.table.position = 'h'
            if 'position' in node:
                self.table.position = node['position']

            return
        #raise nodes.SkipNode

        if 'pdf-no-border' in node['classes'] or 'no-border' in node['classes']:
            self.hline = ''
        else:
            self.hline = '\\hline'


        if self.table:
            raise UnsupportedError(
                '%s:%s: nested tables are not yet implemented.' %
                (self.curfilestack[-1], node.line or ''))
        self.table = Table()
        self.table.longtable = 'longtable' in node['classes']
        self.tablebody = []

        for child in node.traverse():
            if isinstance(child, nodes.literal_block) or \
               isinstance(child, nodes.field_list) or \
               isinstance(child, nodes.bullet_list):
                self.table.simple = False

        self.table.position = 'h'
        if 'position' in node:
            self.table.position = node['position']

        for cs in node.traverse(nodes.colspec):
            self.table.colcount +=1
            self.table.colspec.append(cs.attributes['colwidth'])

        skipcols = [0 for x in range(self.table.colcount)]

        max_width = 0
        total_width = 0
        max_col_widths = {}
        max_single_width = 0
        self.table.max_width_col = 0
        for row in node.traverse(nodes.row):

            colnum = 0
            for col in row.traverse(nodes.entry):
                while colnum < self.table.colcount and skipcols[colnum] > 0:
                    skipcols[colnum] -= 1
                    colnum += 1
                if col.has_key('morecols'):
                    n = int(col['morecols'])+1
                else:
                    n = 1

                if col.has_key('morerows'):
                    k = int(col['morerows'])
                    assert colnum < self.table.colcount, "Table structure is invalid"
                    skipcols[colnum] += 1

                if not colnum in max_col_widths:
                    max_col_widths[colnum] = 0
                text = col.astext()
                width = len(text)

                if n == 1 and width > max_col_widths[colnum]:
                    max_col_widths[colnum] = width

                if n == 1 and width > max_width:
                    max_width = len(text)
                    self.table.max_width_col = colnum
                if width > max_single_width:#
                    max_single_width = width
                colnum=colnum+n

        total_width = 0
        total_width_threshold = 100
        col_threshold = total_width_threshold/len(max_col_widths)

        num_bigcols = 0
        for col,width in max_col_widths.iteritems():
            if width > col_threshold:
                num_bigcols += 1
            total_width += width

        self.table.extra_wide = num_bigcols > 1

        total_width = max(total_width, max_single_width)

        self.table.narrow = \
            (self.next_table_tabularcolumns != None) or (total_width < 70)

        if 'narrow' in node['classes']:
            self.table.narrow = True
        if 'wide' in node['classes']:
            self.table.narrow = False

        self.table.simple = not self.table.extra_wide

#        self.table.simple = 'simple-content' in node['classes']

        self.table.vertical_borders = 'vertical-borders' in node['classes']

        if self.next_table_tabularcolumns and \
           self.next_table_tabularcolumns.find('|') != -1:
            self.table.vertical_borders = True

        self.table.horizontal_borders = 'horizontal-borders' in node['classes']

        self.table.no_hlines = not self.table.horizontal_borders

        self.table.smaller = 'smaller' in node['classes'] or self.table.extra_wide
        self.table.bigger = 'bigger' in node['classes'] or \
                            'larger' in node['classes']

        if self.table.horizontal_borders:
            self.table.hline = '\\hline'
        else:
            self.table.hline = ''

        if self.table.vertical_borders:
            self.table.linesep = '|'
        else:
            self.table.linesep = ''

        if 'pdf-no-border' in node['classes'] or 'no-border' in node['classes']:
            self.table.toprule = ''
            self.table.midrule = ''
            self.table.bottomrule = ''
            self.table.crule = ''
        elif self.table.vertical_borders:
            self.table.toprule = '\\Hline'
            self.table.midrule = '\\hline'
            self.table.bottomrule = '\\hline'
            self.table.crule = '\\cline'
        else:
            self.table.toprule = '\\Toprule'
            self.table.midrule = '\\midrule'
            self.table.bottomrule = '\\bottomrule'
            self.table.crule = '\\cmidrule'
#        if self.builder.config.latex_doctype == 'collection':
            linesep = ''
        # Redirect body output until table is finished.
        self._body = self.body
        self.body = self.tablebody
        self.table.skipcols = [0 for x in range(self.table.colcount)]
        #self.table.colspec = []

    def depart_table(self, node):

        if not 'raw' in node['classes']:
            linesep = self.table.linesep
            hline = self.table.hline
            if self.table.rowcount > 50:
                self.table.longtable = True

        self.body = self._body

        if self.next_table_ids:
            id = self.next_table_ids.pop()
            main_id = '['+self.curfilestack[-1] + ':' + id+']'
            if len(self.next_table_ids) > 0:
                print >>sys.stderr,"WARNING: multiple ids for figure %s" % id
        else:
            main_id = ''
        self.next_table_ids.clear()

        if not self.table.longtable and self.table.caption is not None:
            if self.builder.config.use_sidecaption:
                self.body.append(u'\n\\begin{figure}[%s]'%self.table.position)
                cap = self.table.caption.strip()
                self.body.append(u'\\begin{sidecaption}{%s}%s\n'%(cap,main_id))
#                self.body.append(u'\\begin{minipage}{\\textwidth}\n')
                if self.table.smaller:
                    self.body.append('\n\\footnotesize \\loosertables\n')
                elif not self.table.bigger:
                    self.body.append(u'\small')
            else:
                self.body.append(u'\n\\begin{center}\\begin{threeparttable}\n')
#                             u'\\capstart\\caption{%s}\n' % self.table.caption)
#                             u'\\caption{%s}\n' % self.table.caption)

#        self.body.append('\\begin{center}')

#        self.body.append(ids)
        
        if 'raw' in node['classes']:
            self.body.append('%Raw Table\n')
        elif self.table.longtable:
            self.body.append('\n\\small')
            if self.fullwidth:
                self.body.append('\\setlength\\LTleft{-\\blockindentlen}')
            self.body.append('\\begin{longtable}')
        elif self.next_table_tabularcolumns:
            tc = self.next_table_tabularcolumns
            if tc.find('X') != -1 or tc.find('Y') != -1:
                self.body.append('\n\\begin{tabularx}{\linewidth}')
            else:
                self.body.append('\n\\begin{tabular}')
        elif self.table.has_verbatim or self.table.narrow or self.table.extra_wide:
            self.body.append('\n\\begin{tabular}')
        else:
            self.body.append('\n\\begin{tabularx}{\linewidth}')
#            self.body.append('\n\\begin{center}\\begin{tabulary}{\\linewidth}')

        if 'raw' in node['classes']:
            pass
        elif self.next_table_tabularcolumns:
            colspec_str = self.next_table_tabularcolumns
            self.body.append('{' + colspec_str + '}\n')
        elif self.table.colspec:
            total = float(sum(self.table.colspec))
            colspec_str = ''
            for i in range(len(self.table.colspec)):
                colwidth = self.table.colspec[i]
                colwidth = (colwidth / total)
                if self.table.simple:
                    if not self.table.narrow and i == self.table.max_width_col \
                       and not self.table.longtable:

                        colspec_str += 'Y%s' % (linesep)
                    else:
                        colspec_str += 'l%s' % (linesep)
                else:
                    if self.fullwidth:
                        tw = 122
                    else:
                        tw = 100
                    colspec_str += 'p{%.3fmm}%s' % (colwidth*tw,linesep)
            self.body.append('{%s'%linesep + colspec_str + '}\n')
        else:
#            print node
            if self.table.has_verbatim:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{%s'%linesep + colspec + '}\n')
            elif self.table.longtable:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{|' + colspec + '}\n')
#                self.body.append('{|' + ('l|' * self.table.colcount) + '}\n')
            else:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{%s'%linesep + colspec + '}\n')
#                self.body.append('{|' + ('l|' * self.table.colcount) + '}\n')
#        if self.table.longtable and self.table.caption is not None:
#            self.body.append(u'\\capstart\\caption{%s} \\\\\n' %
#                             self.table.caption)
#        if self.table.caption is not None:
#            for id in self.next_table_ids:
#                self.body.append(self.hypertarget(id, anchor=False))
#            self.next_table_ids.clear()

        if 'raw' in node['classes']:
            pass
        elif self.table.longtable:
            self.body.append('%s\n'%self.table.toprule)
            self.body.append('\\endfirsthead\n\n')
            #self.body.append('\\multicolumn{%s}{c}%%\n' % self.table.colcount)
            #self.body.append(r'{{\bfseries \tablename\ \thetable{} -- %s}} \\'
            #                             % _('continued'))
            self.body.append('%s\n'%self.table.toprule)
            self.body.extend(self.table.thead)
            self.body.append('\n%s\n'%hline)
            self.body.append('\\endhead\n\n')
            self.body.append(ur'%s \multicolumn{%s}{%sr%s}{{%s}} \\ %s'
                             % (hline, self.table.colcount, '','',
                                _('(continued)'),''))
            self.body.append('\n\\endfoot\n\n')
            self.body.append('%s\n'%hline)
            self.body.append('\\endlastfoot\n\n')
        else:
            #self.body.append('\\Hline\n')
            self.body.append('%s\n'%self.table.toprule)

        self.body.extend(self.tablebody)

        if 'raw' in node['classes']:
            pass
        elif self.table.longtable:
            self.body.append('\\end{longtable}\n\n\\normalsize\n')
            #if self.fullwidth:
            #    self.body.append('\\end{adjustwidth}')
        elif self.next_table_tabularcolumns:
            tc = self.next_table_tabularcolumns
            if not self.table.narrow or tc.find('X') != -1 or tc.find('Y') != -1:
                self.body.append('\n\\end{tabularx}')
            else:
                self.body.append('\n\\end{tabular}')
        elif self.table.has_verbatim or self.table.narrow or self.table.extra_wide:
            self.body.append('\\end{tabular}\n\n')
        else:
            self.body.append('\\end{tabularx}\n\n')

#        self.body.append('\\end{center}')

        if not self.table.longtable and self.table.caption is not None:
            if self.builder.config.use_sidecaption:
#                self.body.append(u'\\end{minipage}')
                self.body.append(u'\\end{sidecaption}\n')
                self.body.append('\\end{figure} \\DocumentFooterFix\n')
            else:
                self.body.append(u'\\caption{%s}\n' % self.table.caption)
                self.body.append('\\end{threeparttable}\n\n\\end{center}\n\n')

        self.table = None
        self.tablebody = None
        self.next_table_tabularcolumns = None

    def visit_colspec(self, node):
        pass
 
    def depart_colspec(self, node):
        pass

    def visit_tgroup(self, node):
        pass
    def depart_tgroup(self, node):
        pass

    def visit_thead(self, node):
#        if self.next_table_colspec:
#            self.table.colspec = '{%s}\n' % self.next_table_colspec
#        self.next_table_colspec = None
        self.table.thead_start = len(self.body)
#        self.body.append('\\hline\n')
#        self.table.had_head = True
    def depart_thead(self, node):
        if not self.table.horizontal_borders:
            self.body.append('%s\n'%self.table.midrule)
        self.table.thead = self.body[self.table.thead_start:]

    def visit_tbody(self, node):
        if not self.table.had_head:
            self.visit_thead(node)
    def depart_tbody(self, node):
        self.body.append('%s\n'%self.table.bottomrule)

    def visit_row(self, node):
#        for c in node.children:
#            print c
#            if node.has_key('morecols'):
#                print "mc: %d" % node['morecols']
#           else:
#                print 0
#        print self.table.colcount
#        print len(node.children)

        colcount = len(node.children)
        spanning_header = (self.table.prev_colcount != self.table.colcount and \
                           self.table.prev_colcount == 1) 


        if self.table.horizontal_borders and self.table.rowcount != 0 and \
           not isinstance(node.parent,nodes.thead):
            for i in range(self.table.colcount):
                if self.table.skipcols[i] == 0:
                    self.body.append('%s{%d-%d} %%\n'%(self.table.crule,i+1,i+1))
        elif not self.table.no_hlines:
         if spanning_header or \
                (self.table.prev_colcount != None and \
                 colcount != self.table.prev_colcount):
            for i in range(self.table.colcount):
                if self.table.skipcols[i] == 0:
                    self.body.append('%s{%d-%d}\n'%(self.table.crule,i+1,i+1))

        self.table.prev_colcount = colcount
        # if (self.table.colcount != colcount):
        #     colwidth = 0.90 / colcount
        #     colspec = ('p{%.3f\\linewidth}%s' % (colwidth,self.linesep)) * colcount
        #     self.body.append('\\multicolumn{%d}' % self.table.colcount)
        #     self.body.append('{%s'%self.linesep + colspec + '}{')
        self.table.col = 0

        found_content = False
        for x in node.traverse(nodes.paragraph):
            found_content = True

        if not found_content and not self.table.horizontal_borders:
            self.body.append('%s\n'%self.table.midrule)
            raise nodes.SkipNode

    def depart_row(self, node):
#        if (self.table.colcount != len(node.children)):
#            self.body.append('}')
        while self.table.col < self.table.colcount and self.table.skipcols[self.table.col] > 0:
            self.table.skipcols[self.table.col] = self.table.skipcols[self.table.col]-1
            self.table.col += 1
            self.body.append(' & ')

        self.body.append('\\\\\n')
#        if (self.table.colcount != len(node.children)):
#            self.body.append('\hline\n')
        self.table.rowcount += 1

    def visit_entry(self, node):
        # if node.has_key('morerows'):
        #     raise UnsupportedError('%s:%s: row spanning cells are '
        #                            'not yet implemented.' %
        #                            (self.curfilestack[-1], node.line or ''))
        if node.has_key('morecols') and node.has_key('morerows'):
             raise UnsupportedError('%s:%s: ceels that span columns and rows'
                                    ' are not yet implemented (%s).' %
                                    (self.curfilestack[-1], node.line or '',self.table.caption))
        inc = 1
        while self.table.skipcols[self.table.col] > 0:
            self.table.skipcols[self.table.col] = self.table.skipcols[self.table.col]-1
            if self.table.col > 0:
                self.body.append(' & ')
            self.table.col += 1


        if self.table.col > 0:
            self.body.append(' & ')
        if node.has_key('morecols'):
            n = int(node['morecols'])+1
            inc = n
            total = float(sum(self.table.colspec))
            colwidth = float(sum(self.table.colspec[self.table.col:self.table.col+n]))
            colwidth = (colwidth / total)
            if self.table.col == 0:
                init_div=self.table.linesep
            else:
                init_div=''
            #if self.table.col+n == len(self.table.colspec):
            #    final_div=self.table.linesep
            #else:
            #    final_div=''
            final_div=self.table.linesep
            if self.table.simple:
                if not self.table.narrow and \
                   self.table.col <= self.table.max_width_col and \
                   self.table.col + n > self.table.max_width_col:
                    tabspec = 'X'
                else:
                    tabspec = 'l'

                width = '>{\\setlength{\\hsize}{%d\\hsize}\\addtolength{\\hsize}{%d\\tabcolsep}}%s' % (n,n,tabspec)
                self.body.append('\\multicolumn{%d}{%s%s%s}{' % (n,init_div,width,final_div) )
            else:
                self.body.append('\\multicolumn{%d}{%sp{%.3f\linewidth}%s}{' % (n,init_div,colwidth,final_div) )

#            self.context.append('}')

        if node.has_key('morerows'):
            n = int(node['morerows'])+1
            total = float(sum(self.table.colspec))
            colwidth = float(self.table.colspec[self.table.col])
            colwidth = (colwidth / total) * 1.0
#            self.body.append('\multirow{%d}{%.3f\linewidth}{' % (n,colwidth) )
            self.table.skipcols[self.table.col] += n-1

        self.table.col += inc
        if isinstance(node.parent.parent, nodes.thead):
            self.body.append('\\textbf{')
            self.in_strong = True
            self.context.append('}')
        else:
            self.context.append('')

    def depart_entry(self, node):
        if isinstance(node.parent.parent, nodes.thead):
            self.in_strong = False

        if node.has_key('morecols'):
            self.body.append('}')
        if node.has_key('morerows'):
            pass
#            self.body.append('}')

        self.body.append(self.context.pop()) # header

    def visit_acks(self, node):
        # this is a list in the source, but should be rendered as a
        # comma-separated list here
        self.body.append('\n\n')
        self.body.append(', '.join(n.astext()
                                   for n in node.children[0].children) + '.')
        self.body.append('\n\n')
        raise nodes.SkipNode

    def visit_bullet_list(self, node):
        if not self.compact_list:
            if 'nopoints' in node['classes']:
                #print >>sys.stderr, "DEBUG"
                print >>sys.stderr, node
                if 'compact' in node['classes']:
                    self.body.append('\\begin{compactnopoints}\n' )
                else:
                    self.body.append('\\begin{nopoints}\n' )
            else:
                if 'compact' in node['classes']:
                    self.body.append('\\begin{compactpoints}\n' )
                else:
                    self.body.append('\\begin{itemize}\n' )

    def depart_bullet_list(self, node):
        if not self.compact_list:
            if 'nopoints' in node['classes']:
                if 'compact' in node['classes']:
                    self.body.append('\\end{compactnopoints}\n\n' )
                else:
                    self.body.append('\\end{nopoints}\n\n' )
            else:
                if 'compact' in node['classes']:
                    self.body.append('\\end{compactpoints}\n\n' )
                else:
                    self.body.append('\\end{itemize}\n\n' )

    def visit_enumerated_list(self, node):
        if 'steps' in node['classes']:
            if 'compact' in node['classes']:
                self.body.append('\\begin{compactsteps}\n' )
            else:
                self.body.append('\\begin{steps}\n' )
        else:
            self.body.append('\\begin{enumerate}\n' )
        if 'start' in node:
            self.body.append('\\setcounter{enumi}{%d}\n' % (node['start'] - 1))
    def depart_enumerated_list(self, node):
        if 'steps' in node['classes']:
            if 'compact' in node['classes']:
                self.body.append('\\end{compactsteps}\n\n' )
            else:
                self.body.append('\\end{steps}\n\n' )
        else:
            self.body.append('\\end{enumerate}\n\n' )

    def visit_list_item(self, node):
        # Append "{}" in case the next character is "[", which would break
        # LaTeX's list environment (no numbering and the "[" is not printed).
        self.body.append(r'\item   ')
        self.in_list_item = True

    def depart_list_item(self, node):
        self.body.append('\n')
        self.in_list_item = False

    def visit_definition_list(self, node):
        self.body.append('\\begin{description}\n')

    def depart_definition_list(self, node):
        self.body.append('\\end{description}\n\n')

    def visit_definition_list_item(self, node):
        pass

    def depart_definition_list_item(self, node):
        pass

    def visit_term(self, node):
#        ctx = '}] \\leavevmode'
        self.body.append('\\item[')
        ctx = ']'
        if node.has_key('ids') and node['ids']:
            ctx += self.hypertarget(node['ids'][0])
#        self.body.append('\\item[{')
        self.in_term = True
        self.context.append(ctx)

    def depart_term(self, node):
        self.body.append(self.context.pop())
        self.in_term = False

    def visit_classifier(self, node):
        self.body.append('{[}')

    def depart_classifier(self, node):
        self.body.append('{]}')

    def visit_definition(self, node):
        pass

    def depart_definition(self, node):
        self.body.append('\n')

    def visit_field_list(self, node):
        self.body.append('\n\n')
        if 'actions' in node['classes']:
            self.body.append('\\begin{actions}\n\n')
            for f in node.traverse(nodes.field):
                f['classes'].append('action')
            for f in node.traverse(nodes.field_body):
                f['classes'].append('action')
            for f in node.traverse(nodes.field_name):
                f['classes'].append('action')
            self.sectionlevel += 1
        else:
            node['classes'].append('latex_compact')
            if 'latex_compact' in node['classes']:
                for f in node.traverse(nodes.field_name):
                    f['classes'].append('latex_compact')
                self.body.append('\\begin{option}\n\n')
                #            exit(1)
#        self.body.append('\\begin{tabular}{ll}')
#        self.body.append('\\begin{quote}\\begin{description}\n')
        pass
    def depart_field_list(self, node):
       if 'actions' in node['classes']:
           self.sectionlevel -= 1
           self.body.append('\\end{actions}\n\n')
       else:
           if 'latex_compact' in node['classes']:
               self.body.append('\\end{option}\n\\vspace{-3mm}\n\n')

#        self.body.append('\\end{description}\\end{quote}\n')
#        self.body.append('\\end{tabular} \n \n')
       pass

    def visit_field(self, node):
#        if 'action' in node['classes']:
#            self.body.append('\\item{')
#        self.body.append('\n\n\\textbf{')
#        self.body.append('abc ')
#        self.context.append('}')
        try:
            body_start = node[1][0][0]
        except:
            body_start = None

        self.field_start_pos = len(self.body)
        if isinstance(body_start, nodes.image) and 'iconmargin' in body_start['classes']:
            node[1][0]['hoist_icons'] = True
        pass

    def depart_field(self, node):
#        if 'action' in node['classes']:
#            self.body.append('}\n\n')
#        self.body.append('}\n\n')
        pass

    def visit_field_name(self, node):
#        print self.sectionlevel
        if 'latex_compact' in node['classes']:
            self.body.append('\\item[')
        elif 'action' in node['classes']:
#            if self.sectionlevel == 2:
#                self.body.append('\\vspace{\\baselineskip}\n')
#            self.body.append('\\%s*{'%self.sectionnames[self.sectionlevel+1])
            self.body.append('\\item ')
            self.body.append('\\textbf{')
        else:
            self.body.append('\\textbf{')

    def depart_field_name(self, node):
        if 'latex_compact' in node['classes']:
            self.body.append(']')

        elif 'action' in node['classes']:
#            if self.sectionlevel == 2:
#                self.body.append('}\n')
#                self.body.append('\\vspace{-\\baselineskip}\n')
#            else:
                self.body.append(':} ')

        else:
            self.body.append(':}')
#        self.body.append('}\n\n')
        pass
        
#    visit_field_name = visit_term
#    depart_field_name = depart_term

    def visit_field_body(self, node):
        pass
    def depart_field_body(self,node):
        self.body.append('\n')

    def visit_paragraph(self, node):
#        if isinstance(node.parent,nodes.admonition):
#            print "ADM"
        self.para_icons = []
        self.para_inserts = []
        self.para_icon_insert_point = len(self.body)
        self.para_sloppy = False
        para_index = node.parent.index(node)
        if not isinstance(node.parent, nodes.entry) and \
           not isinstance(node.parent, nodes.strong) and \
           not isinstance(node.parent, nodes.field_body) and \
           not isinstance(node.parent, collected_footnote) and \
           not (isinstance(node.parent, nodes.list_item) and para_index==0):
            self.body.append('\n\n')
        else:
            self.body.append('')

    def depart_paragraph(self, node):

        if 'windows' in node['classes']:
            self.para_inserts.append('\\windowsmargin')

        if 'mac' in node['classes']:
            self.para_inserts.append('\\macmargin')

        if 'linux' in node['classes']:
            self.para_inserts.append('\\linuxmargin')

        for i in range(self.para_icon_insert_point,len(self.body)):
            try:
                pre = self.body[i][-1]
                post = self.body[i+2][0]
                mid = self.body[i+1][0:5]
            except:
                continue

            if pre == '`' and post == '`' and mid == '\\verb':
                self.body[i+2] = '\'' + self.body[i+2][1:]

        icon_str = ''

        for m in node['margin_items']:
            icon_str += m+' '
        pos = self.para_icon_insert_point

        for i in range(pos, len(self.body)):
            if self.body[i] == 'ihjsqueezeihj':
                self.body[i-1] = self.body[i-1].rstrip()
                self.body[i] = ''
                self.body[i+1] = self.body[i+1].lstrip()

            if re.match(r'.*\\texttrademark',self.body[i]):
                self.body[i-1] = self.body[i-1].rstrip()

        for i in range(pos, len(self.body)):
            if re.match('.*\\mbox{',self.body[i-1]):
                self.body[i] = self.body[i].lstrip()

        if self.para_sloppy:
            self.body[pos] = self.body[pos] + '\\sloppy\n'

        if 'hoist_icons' in node:
            pos = self.field_start_pos


        if len(node.astext()) > 70:
            default_icon_command = 'iconmargin{2}'
        else:
            default_icon_command = 'iconmarginraise{1}'

        if self.para_icons:
            if len(self.para_icons) == 2:
                command = self.para_icons[0][1]
                if not command:
                    command = default_icon_command
                icon_str += "\\double%s{%s}{%s}" % (command,
                                                       self.para_icons[0][0],
                                                       self.para_icons[1][0])
            else:
                for icon,command in self.para_icons:
                    if not command:
                        command = default_icon_command
                    icon_str += '\\%s{%s} ' % (command, icon)
#        icon_str += ' '

        icon_str += ' '.join(self.para_inserts)

        first = self.body[pos+1]

        if re.match('Figure~.ref{.*}',first):
            pos += 1
            first = self.body[pos+1]

        if first == '\\textbf{' and icon_str != '':
            i = string.find(self.body[pos+2],' ')
            first = '\\textbf{%s}'%self.body[pos+2][0:i]
            self.body[pos+2] = '\\textbf{'+self.body[pos+2][i+1:]
            n = len(first)
        else:
            n = len(first) - len(first.lstrip())
            n = string.find(first,' ',n)

        self.body[pos+1] = first[:n] + icon_str + first[n:]
#        self.body = self.body[:pos] + ' gg ' + self.body[pos:]
        if not isinstance(node.parent, nodes.entry) and \
           not isinstance(node.parent, collected_footnote):
            self.body.append('\n')
        if self.para_sloppy:
            self.body.append('\n\\fussy\n\n')
        self.para_icons = None

    def visit_centered(self, node):
        self.body.append('\n\\begin{center}')
    def depart_centered(self, node):
        self.body.append('\n\\end{center}')

    def visit_hlist(self, node):
        # for now, we don't support a more compact list format
        # don't add individual itemize environments, but one for all columns
        self.compact_list += 1
        self.body.append('\\begin{itemize}\\setlength{\\itemsep}{0pt}'
                         '\\setlength{\\parskip}{0pt}\n')
    def depart_hlist(self, node):
        self.compact_list -= 1
        self.body.append('\\end{itemize}\n\n')

    def visit_hlistcol(self, node):
        pass
    def depart_hlistcol(self, node):
        pass

    def latex_image_length(self, width_str):
        match = re.match('(\d*\.?\d*)\s*(\S*)', width_str)
        if not match:
            # fallback
            return width_str
        res = width_str
        amount, unit = match.groups()[:2]
        if not unit or unit == "px":
            # pixels: let LaTeX alone
            return None
        elif unit == "%":
            res = "%.3f\\linewidth" % (float(amount) / 100.0)
        return res

    def is_inline(self, node):
        """Check whether a node represents an inline element."""
        return isinstance(node.parent, nodes.TextElement)

    def visit_image(self, node):
        attrs = node.attributes
        if 'iconmargin' in node['classes']:
            #print node['uri']
            if re.match('.*windowsmargin\.png',node['uri']):
                self.para_inserts.append('\\windowsmargin')
            elif re.match('.*linuxmargin\.png',node['uri']):
                self.para_inserts.append('\\linuxmargin')
            elif re.match('.*macmargin\.png',node['uri']):
                self.para_inserts.append('\\macmargin')
            else:
                command = None
                if 'iconmarginraise' in node:
                    if 'iconmarginheight' in node:
                        command = 'iconmarginraise{%d}' \
                                            % node['iconmarginheight']
                    else:
                        command = 'iconmarginraise{1}'
                elif 'iconmarginheight' in node:
                    command = 'iconmargin{%d}' % node['iconmarginheight']

                self.para_icons.append((node['uri'], command))
            return
        pre = []                        # in reverse order
        post = []
#        include_graphics_options = []
        if hasattr(self, 'include_graphics_options'):
            include_graphics_options = self.include_graphics_options
        else:
            include_graphics_options = []
        is_inline = self.is_inline(node)
        if attrs.has_key('scale'):
            # Could also be done with ``scale`` option to
            # ``\includegraphics``; doing it this way for consistency.
            pre.append('\\scalebox{%f}{' % (attrs['scale'] / 100.0,))
            post.append('}')
        if attrs.has_key('width'):
            w = self.latex_image_length(attrs['width'])
            if w:
                include_graphics_options.append('width=%s' % w)
        else:
            include_graphics_options.append('width=\\ScaleIfNeeded')

        if attrs.has_key('height'):
            h = self.latex_image_length(attrs['height'])
            if h:
                include_graphics_options.append('height=%s' % h)
        if attrs.has_key('align'):
            align_prepost = {
                # By default latex aligns the top of an image.
                (1, 'top'): ('', ''),
                (1, 'middle'): ('\\raisebox{-0.5\\height}{', '}'),
                (1, 'bottom'): ('\\raisebox{-\\height}{', '}'),
                (0, 'center'): ('{\\hfill', '\\hfill}'),
                # These 2 don't exactly do the right thing.  The image should
                # be floated alongside the paragraph.  See
                # http://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
                (0, 'left'): ('{', '\\hfill}'),
                (0, 'right'): ('{\\hfill', '}'),}
            try:
                pre.append(align_prepost[is_inline, attrs['align']][0])
                post.append(align_prepost[is_inline, attrs['align']][1])
            except KeyError:
                pass
        if is_inline:
            pre.append('\\raisebox{-1mm}{')
            post.append('}')
        if not is_inline:
            pre.append('\n')
            post.append('\n')
        pre.reverse()
        if node['uri'] in self.builder.images:
            uri = self.builder.images[node['uri']]
        else:
            # missing image!
            if self.ignore_missing_images:
                return
            uri = node['uri']
        if uri.find('://') != -1:
            # ignore remote images
            return
        self.body.extend(pre)
        options = ''
        if include_graphics_options:
            options = '[%s]' % ','.join(include_graphics_options)
        self.body.append('\\includegraphics%s{%s}' % (options, uri))
        self.body.extend(post)
        self.include_graphics_options=[]
    def depart_image(self, node):
        pass

    def visit_figure(self, node):
        self._figsavedbody = self.body
        self.body = []
        self.caption = None

    def depart_figure(self, node):
        ids = ''
        figbody = self.body
        self.body = self._figsavedbody
        position = 'h'
        if 'position' in node:
            position = node['position']

        if self.next_figure_ids:
            id = self.next_figure_ids.pop()
            main_id = '['+self.curfilestack[-1] + ':' + id+']'
            if len(self.next_figure_ids) > 0:
                print >>sys.stderr,"WARNING: multiple ids for figure %s" % id
        else:
            main_id = ''
        self.next_figure_ids.clear()

        node['align'] = 'left'
        self.body.append('\\begin{figure}[%s]\n'%position)
        if not self.caption:
            print >>sys.stderr,"ERROR: LaTeX generator error: No caption for figure\n"
            sys.exit(1)
        cap = self.caption.strip()

        self.body.append(u'\\begin{sidecaption}{%s}%s\n'%(cap,main_id))

        end = ids + '\\end{sidecaption}'
        end += '\\end{figure} \\DocumentFooterFix\n'
        self.context.append(end)
        if node.has_key('width'):
            node[0]['width'] = node['width']

        self.body += figbody

        self.body.append(self.context.pop())

    visit_general_figure = visit_figure
    depart_general_figure = depart_figure

    def visit_caption(self, node):
        self._savedcapbody = self.body
        self.body = []
        self.in_title = True

    def depart_caption(self, node):
        self.caption = ''.join(self.body)
        self.body = self._savedcapbody
        self.in_title = False

    def visit_legend(self, node):
        self.body.append('{\\small ')

    def depart_legend(self, node):
        self.body.append('}')

    def visit_admonition(self, node):
#        self.body.append('\n\\begin{notice}{note}')
        self.body.append('\n\n')

    def depart_admonition(self, node):
#        self.body.append('\\end{notice}\n')
        pass

    def _make_visit_admonition(name):
        def visit_admonition(self, node):
           if 'no-raise' in node['classes']:
               raise_txt = ''
           elif len(node.astext()) < 70 or 'raise' in node['classes']:
               raise_txt = 'raise'
           else:
               raise_txt = ''

           for p in node.traverse(nodes.paragraph):

               p['margin_items'].append("\%smargin%s" % (xmoslatex_admonitionlabels[name],raise_txt))
               break

        return visit_admonition

    def _depart_named_admonition(self, node):
        pass

    visit_attention = _make_visit_admonition('attention')
    depart_attention = _depart_named_admonition
    visit_caution = _make_visit_admonition('caution')
    depart_caution = _depart_named_admonition
    visit_danger = _make_visit_admonition('danger')
    depart_danger = _depart_named_admonition
    visit_error = _make_visit_admonition('error')
    depart_error = _depart_named_admonition
    visit_hint = _make_visit_admonition('hint')
    depart_hint = _depart_named_admonition
    visit_important = _make_visit_admonition('important')
    depart_important = _depart_named_admonition
    visit_note = _make_visit_admonition('note')
    depart_note = _depart_named_admonition
    visit_tip = _make_visit_admonition('tip')
    depart_tip = _depart_named_admonition
    visit_warning = _make_visit_admonition('warning')
    depart_warning = _depart_named_admonition

    visit_newinxc = _make_visit_admonition('newinxc')
    depart_newinxc = _depart_named_admonition

    def visit_versionmodified(self, node):
        intro = versionlabels[node['type']] % node['version']
        if node.children:
            intro += ': '
        else:
            intro += '.'
        self.body.append(intro)
    def depart_versionmodified(self, node):
        pass

    def visit_target(self, node):
        def add_target(id):
            #print id
            # indexing uses standard LaTeX index markup, so the targets
            # will be generated differently
            if id.startswith('index-'):
                return
            # do not generate \phantomsection in \section{}
            anchor = not self.in_title
            self.body.append(self.hypertarget(id, anchor=anchor))

        # postpone the labels until after the sectioning command
        parindex = node.parent.index(node)
        try:
            try:
                next = node.parent[parindex+1]
            except IndexError:
                # last node in parent, look at next after parent
                # (for section of equal level)
                next = node.parent.parent[node.parent.parent.index(node.parent)]
            if isinstance(next, nodes.section):
                if node.get('refid'):
                    self.next_section_ids.add(node['refid'])
                self.next_section_ids.update(node['ids'])
                return
            elif isinstance(next, nodes.figure) or \
                 next.__class__.__name__ == 'general_figure':
                # labels for figures go in the figure body, not before
                if node.get('refid'):
                    self.next_figure_ids.add(node['refid'])
                self.next_figure_ids.update(node['ids'])
                return
            elif isinstance(next, nodes.table):
                # same for tables, but only if they have a caption
                if node.get('refid'):
                    self.next_table_ids.add(node['refid'])
                self.next_table_ids.update(node['ids'])
                return
        except IndexError:
            pass
        if 'refuri' in node:
            return
        if node.get('refid'):
            add_target(node['refid'])
        for id in node['ids']:
            add_target(id)
    def depart_target(self, node):
        pass

    def visit_attribution(self, node):
        self.body.append('\n\\begin{flushright}\n')
        self.body.append('---')
    def depart_attribution(self, node):
        self.body.append('\n\\end{flushright}\n')

    def visit_index(self, node, scre=re.compile(r';\s*')):
        entries = node['entries']
        for type, string, tid, _ in entries:
            if type == 'single':
                self.body.append(r'\index{%s}' %
                                 scre.sub('!', self.encode(string)))
            elif type == 'pair':
                parts = tuple(self.encode(x.strip())
                              for x in string.split(';', 1))
                try:
                    self.body.append(r'\indexii{%s}{%s}' % parts)
                except TypeError:
                    self.builder.warn('invalid pair index entry %r' % string)
            elif type == 'triple':
                parts = tuple(self.encode(x.strip())
                              for x in string.split(';', 2))
                try:
                    self.body.append(r'\indexiii{%s}{%s}{%s}' % parts)
                except TypeError:
                    self.builder.warn('invalid triple index entry %r' % string)
            else:
                self.builder.warn('unknown index entry type %s found' % type)
        raise nodes.SkipNode

    def visit_raw(self, node):
        if 'latex' in node.get('format', '').split():
            self.body.append(node.astext())
        raise nodes.SkipNode

    def visit_reference(self, node):

        if re.match('[s|S]ee[ |\n]',self.body[-1][-4:]):
            self.body[-1] = self.body[-1][:-1] + '~'

        uri = node.get('refuri', '')
        if not uri and node.get('refid'):
            uri = '%' + self.curfilestack[-1] + '#' + node['refid']
        if self.in_title or not uri:
            self.context.append('')
        elif not 'xmosxref' in node and (uri.startswith('mailto:') or uri.startswith('http:') or \
                 uri.startswith('https:') or uri.startswith('ftp:') or \
                 uri.startswith('/')):

            if uri.startswith('/'):
                uri = 'http://www.xmos.com'+uri

            if node.astext() == uri:
                if isinstance(node.parent,nodes.paragraph) and len(node.parent)==2:
                    self.body.append('\\parurl{%s}' % self.encode_uri(uri))
                else:
                    self.body.append('\\xurl{%s}' % self.encode_uri(uri))
                raise nodes.SkipNode
            elif 'xmosxref' in node or node.astext()=='???':
                self.body.append('\\href{%s}{' % self.encode_uri(uri))
                self.context.append('}')
            else:
                self.context.append('\\footnote{\\xurl{%s}}' % self.encode_uri(uri))

            #     self.body.append('\\href{%s}{' % self.encode_uri(uri))
            # # if configured, put the URL after the link
            #     if self.builder.config.latex_show_urls and \
            #             node.astext() != uri:
            #         if uri.startswith('mailto:'):
            #             uri = uri[7:]
            #         self.context.append('} (%s)' % self.encode_uri(uri))
            #     else:
            #         self.context.append('}')
        elif uri.startswith('#'):
            # references to labels in the same document
            id = self.curfilestack[-1] + ':' + uri[1:]
            #print node
            skip, link, post = self.hyperlink(node, id)
            self.body.append(link)
            if skip:
                raise nodes.SkipNode
            self.context.append(post)
        elif uri.startswith('%') or 'xmosxref' in node:
            # references to documents or labels inside documents
            hashindex = uri.find('#')
            if hashindex == -1:
                # reference to the document
                id = uri[1:] + '::doc'
            elif not 'xmosxref' in node:
                # reference to a label
                id = uri[1:].replace('#', ':')
            else:
                id = uri
            #print node
            skip, link,post = self.hyperlink(node, id)
            self.body.append(link)
            if skip:
                raise nodes.SkipNode
            self.context.append(post)
        elif uri.startswith('@token'):
            if self.in_production_list:
                self.body.append('\\token{')
            else:
                self.body.append('\\grammartoken{')
            self.context.append('}')
        else:
            self.builder.warn(
                'unusable reference target found: %s' % uri,
                '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                           node.line or ''))
            self.context.append('')
        self.in_reference = True
    def depart_reference(self, node):
        self.body[-1] = self.body[-1].rstrip()
        if self.body[-1][-1] == '.':
            self.body[-1]=self.body[-1][:-1]

        self.in_reference = False
        self.body.append(self.context.pop())

    def visit_download_reference(self, node):
        pass
    def depart_download_reference(self, node):
        pass

    def visit_pending_xref(self, node):
        pass
    def depart_pending_xref(self, node):
        pass

    def visit_emphasis(self, node):
        if hasattr(self,'no_emph') and self.no_emph == 1:
            self.body.append('\\begin{comment}')
        elif self.in_cmd:
            self.body.append(r'\optemph{')
        elif not isinstance(node.parent, addnodes.desc_parameter):
            self.body.append(r'\emph{')
    def depart_emphasis(self, node):
        if hasattr(self,'no_emph') and self.no_emph == 1:
            self.no_emph = 0
            self.body.append('\\end{comment}\n')
        elif not isinstance(node.parent, addnodes.desc_parameter):
            self.body.append('}')

    def visit_literal_emphasis(self, node):
        self.body.append(r'\emph{\texttt{')
        self.no_contractions += 1
    def depart_literal_emphasis(self, node):
        self.body.append('}}')
        self.no_contractions -= 1

    def visit_strong(self, node):
        if str(node[0]) == 'Enum Values:':
            node.parent.parent[1]['classes'].append('skip')
            self.body.append('This type has the following values:\n')
            raise nodes.SkipNode
        if str(node[0]) == 'Structure Members:':
            self.body.append('This structure has the following members:\n')
            raise nodes.SkipNode

        self.body.append(r'\textbf{')
        self.in_strong = True

    def depart_strong(self, node):
        self.body.append('}')
        self.in_strong = False

    def visit_abbreviation(self, node):
        abbr = node.astext()
        self.body.append(r'\textsc{')
        # spell out the explanation once
        if node.hasattr('explanation') and abbr not in self.handled_abbrs:
            self.context.append('} (%s)' % self.encode(node['explanation']))
            self.handled_abbrs.add(abbr)
        else:
            self.context.append('}')
    def depart_abbreviation(self, node):
        self.body.append(self.context.pop())

    def visit_title_reference(self, node):
        self.body.append(r'\emph{')
    def depart_title_reference(self, node):
        self.body.append('}')

    def visit_citation(self, node):
        # TODO maybe use cite bibitems
        self.bibitems.append(['', '', ''])  # [citeid, citetext, docname]
        self.context.append(len(self.body))
    def depart_citation(self, node):
        size = self.context.pop()
        text = ''.join(self.body[size:])
        del self.body[size:]
        # remove first word which is duplicated citation name
        self.bibitems[-1][1] = ' '.join(str.split(str(text),'\n')[1:])
#       print str.split(str(text),' ')
#       self.bibitems[-1][1] = text
        bi = self.bibitems[-1]
        target = self.hypertarget(bi[2] + ':' + bi[0].lower(),
                                  withdoc=False)
        self.body.append(u'\n%s\n[%s] \\raggedright {%s}\n' %
                         (target,bi[0], bi[1]))

    def visit_citation_reference(self, node):
        # This is currently never encountered, since citation_reference nodes
        # are already replaced by pending_xref nodes in the environment.
        self.body.append('\\cite{%s}' % self.idescape(node.astext()))
        raise nodes.SkipNode

    def visit_literal(self, node):
        self.no_contractions += 1
        content = self.encode(node.astext().strip())
        self.no_contractions -= 1
        if self.in_title:
            self.body.append(r'\texttt{%s}' % content)
        elif node.has_key('role') and node['role'] == 'samp':
            self.body.append(r'\samp{%s}' % content)
        elif self.in_term:
            self.body.append(r'\ttfamily %s' % content)
        elif self.in_footnote or self.in_reference or self.in_subscript or self.in_strong or self.in_term:
            self.body.append(r'\code{%s}' % content)
        else:
            text = node.astext().strip()
            text = text.replace(' %','` \\texttt{\\ihjkel}\\verb`')
            text = text.replace('%','`\\texttt{\\%}\\verb`')
            text = text.replace('@','`\\texttt{\\raisebox{0.05em}{\\footnotesize{\\MVAt}}}\\verb`')
            text = text.replace('ihjkel','%')

            self.body.append('\\verb`%s`' % text)
        raise nodes.SkipNode

    def visit_footnote_reference(self, node):
        num = node.astext().strip()
        try:
            footnode, used = self.footnotestack[-1][num]
        except (KeyError, IndexError):
            raise nodes.SkipNode
        # if a footnote has been inserted once, it shouldn't be repeated
        # by the next reference
        if used:
            self.body.append('\\footnotemark[%s]' % num)
        else:
            footnode.walkabout(self)
            self.footnotestack[-1][num][1] = True
        raise nodes.SkipChildren
    def depart_footnote_reference(self, node):
        pass

    def visit_literal_block(self, node):
        self.verbatim = ''

    def depart_literal_block(self, node):
        def ispragma(line):
            return (len(line)>0 and line[0] == '#')
        def isblankline(line):
            return (re.match('\s*$',line)!=None)

        code = self.verbatim.rstrip('\n')
        if 'iscode' in node and node['iscode']:
            lines = code.split('\n')
            min_indent=1000
            for line in lines:
                if not isblankline(line) and not ispragma(line):
                    indent = len(re.match('(\s*).*',line).groups(0)[0])
                    min_indent = min(min_indent, indent)

            for i in range(len(lines)):
                if not ispragma(lines[i]) and not isblankline(lines[i]):
                    lines[i] = lines[i][min_indent:]

            code = '\n'.join(lines)

        lang = self.hlsettingstack[-1][0]
        linenos = code.count('\n') >= self.hlsettingstack[-1][1] - 1
        if node.has_key('language'):
            # code-block directives
            lang = node['language']
        if node.has_key('linenos'):
            linenos = node['linenos']

        max_line_width = max([len(x) for x in code.split('\n')])

        options=''
        if max_line_width > 65:
            options='basicstyle=\\ttfamily\\Smaller'

#        print code
#        hlcode = self.highlighter.highlight_block(code, lang, linenos)
#        print hlcode
#        hlcode = '\begin{Verbatim}\n' + code + '\n\end{Verbatim}\n'

        if not self.in_list_item:
            options += ',resetmargins=true'

        hlcode = '\\vspace{-5pt}\\begin{minipage}{\\linewidth}\n\\begin{lstlisting}[%s]\n'%options + code

        # workaround for Unicode issue
        hlcode = hlcode.replace(u'€', u'@texteuro[]')
        # must use original Verbatim environment and "tabular" environment
        if self.table:
            hlcode = hlcode.replace('\\begin{Verbatim}',
                                    '\\begin{OriginalVerbatim}')
            self.table.has_verbatim = True
        else:
            # hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=\\\\\\{\\}]',
            #                         '\\begin{SaveVerbatim}[commandchars=\\\\\\{\\}]{savedenv}')
            # hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=@\\[\\]]',
            #                         '\\begin{SaveVerbatim}[commandchars=@\\[\\]]{savedenv}')

            hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=\\\\\\{\\}]',
                                    '\\begin{minipage}{\\linewidth}\n\\begin{lstlisting}')
            hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=@\\[\\]]',
                                    '\\begin{minipage}{\\linewidth}\n\\begin{lstlisting}}')
#                                    '\begin{Verbatim}[frame=lines,')
#                                    '\\begin{shaded}\n\\topsep=0ex\\relax\n\\begin{Verbatim}[frame=lines,')
                           
            pass
        # get consistent trailer
#        hlcode = hlcode.rstrip()[:-14] # strip \end{Verbatim}
        hlcode = hlcode.rstrip() + '\n'
#        self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\\end{shaded}\n' %  (self.table and 'Original' or ''))
        if self.table:
            self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\n' %  (self.table and 'Original' or ''))
        else:
#            self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\n' %  (self.table and 'Original' or ''))

            if self.builder.config.tiny_verbatim:
                tinyv = '\\tiny'
            else:
                tinyv = '\\small'

            self.body.append('\n' + hlcode + '\\end{lstlisting}\n\\end{minipage}\n\n')
#            self.body.append('\n\\vspace{0.25\\baselineskip}\n' + hlcode + '\\end{SaveVerbatim}\n\\colorbox{lightgrey}{\\parbox{0.98\\textwidth}{%s \\BUseVerbatim{savedenv} \\normalsize }}\n\n\\vspace{0.25\\baselineskip}\n' % tinyv)
        self.verbatim = None
    visit_doctest_block = visit_literal_block
    depart_doctest_block = depart_literal_block

    def visit_line_block(self, node):
        """line-block:
        * whitespace (including linebreaks) is significant
        * inline markup is supported.
        * serif typeface
        """
        self.body.append('{\\raggedright{}')
        self.literal_whitespace += 1

    def depart_line_block(self, node):
        self.literal_whitespace -= 1
        # remove the last \\
        del self.body[-1]
        self.body.append('}\n')

    def visit_line(self, node):
        self._line_start = len(self.body)

    def depart_line(self, node):
        if self._line_start == len(self.body):
            # no output in this line -- add a nonbreaking space, else the
            # \\ command will give an error
            self.body.append('~')
        if self.table is not None:
            self.body.append('\\newline\n')
        else:
            self.body.append('\\\\\n')

    def visit_block_quote(self, node):
        # If the block quote contains a single object and that object
        # is a list, then generate a list not a block quote.
        # This lets us indent lists.
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            if not 'skip' in node['classes']:
                self.body.append('\\begin{indentation}{\\forceindentlen}{0mm}')
            if 'commentary' in node['classes']:
                self.body.append('\small\n')

    def depart_block_quote(self, node):
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            #if 'commentary' in node['classes']:
            #    self.body.append('\\end{commentary}\n')
            if not 'skip' in node['classes']:
                self.body.append('\\end{indentation}')

    # option node handling copied from docutils' latex writer

    def visit_option(self, node):
        if self.context[-1]:
            # this is not the first option
            self.body.append(', ')

    def depart_option(self, node):
        # flag that the first option is done.
        self.context[-1] += 1

    def visit_option_argument(self, node):
        """The delimiter betweeen an option and its argument."""
        self.body.append(node.get('delimiter', ' '))

    def depart_option_argument(self, node):
        pass

    def visit_option_group(self, node):
        self.body.append('\\item [')
        # flag for first option
        self.context.append(0)

    def depart_option_group(self, node):
        self.context.pop() # the flag
        self.body.append('] ')

    def visit_option_list(self, node):
        self.body.append('\\begin{optionlist}{3cm}\n')

    def depart_option_list(self, node):
        self.body.append('\\end{optionlist}\n')

    def visit_option_list_item(self, node):
        pass
    def depart_option_list_item(self, node):
        pass

    def visit_option_string(self, node):
        ostring = node.astext()
        self.no_contractions += 1
        self.body.append(self.encode(ostring))
        self.no_contractions -= 1
        raise nodes.SkipNode

    def visit_description(self, node):
        self.body.append(' ')
    def depart_description(self, node):
        pass

    def visit_superscript(self, node):
        self.body[-1] = self.body[-1].rstrip()
        self.body.append('$^{\\text{')
    def depart_superscript(self, node):
        self.body.append('}}$')

    def visit_subscript(self, node):
        self.body[-1] = self.body[-1].rstrip()
        self.body.append('$_{\\text{')
        self.in_subscript = True

    def depart_subscript(self, node):
        self.body.append('}}$')
        self.in_subscript = False

    def visit_substitution_definition(self, node):
        raise nodes.SkipNode

    def visit_substitution_reference(self, node):
        raise nodes.SkipNode

    def visit_inline(self, node):
        classes = node.get('classes', [])
        if 'tt' in classes:
            self.in_tt = True
            self.body.append('\\texttt{')
        elif 'cmd' in classes:
            self.in_tt = True
            self.in_cmd = True
            if isinstance(node.parent,nodes.paragraph) and len(node.parent)==1 \
               and not (isinstance(node.parent.parent,nodes.list_item) and \
                        node.parent.parent[0] == node.parent):
                self.body.append('\\command{')
            else:
                self.para_sloppy = True
                self.body.append('\\texttt{')
        elif 'missing-reference' in classes:
            self.body.append('{\\begingroup \\hypersetup{urlcolor=red} ')
#        self.body.append(r'\DUspan{%s}{' % ','.join(classes))

    def depart_inline(self, node):
        classes = node.get('classes', [])

        if 'tt' in classes:
            self.body.append('}')
            self.in_tt = False
        elif 'cmd' in classes:
            self.body.append('}')
            self.in_tt = False
            self.in_cmd = False
        elif 'missing-reference' in classes:
            self.body.append('\\endgroup}')

#        self.body.append('}')
        pass

    def visit_generated(self, node):
        pass

    def depart_generated(self, node):
        pass

    def visit_compound(self, node):
        pass

    def depart_compound(self, node):
        pass

    def visit_container(self, node):
        pass

    def depart_container(self, node):
        pass

    def visit_decoration(self, node):
        pass

    def depart_decoration(self, node):
        pass

    # docutils-generated elements that we don't support

    def visit_header(self, node):
        raise nodes.SkipNode

    def visit_footer(self, node):
        raise nodes.SkipNode

    def visit_docinfo(self, node):
        raise nodes.SkipNode

    # text handling

    def encode(self, text):
        text = unicode(text).translate(tex_escape_map)
        if self.literal_whitespace:
            # Insert a blank before the newline, to avoid
            # ! LaTeX Error: There's no line here to end.
            text = text.replace(u'\n', u'~\\\\\n').replace(u' ', u'~')
        if self.no_contractions:
            text = text.replace('--', u'-{-}')
        return text

    def encode_uri(self, text):
        # in \href, the tilde is allowed and must be represented literally
        return self.encode(text).replace('\\textasciitilde{}', '~')

    def visit_Text(self, node):
        if self.verbatim is not None:
            self.verbatim += node.astext()
        else:
            text = node.astext()

            text = self.encode(text)
            if not self.in_sig and not self.in_tt:
                text = educate_quotes_latex(text)
            else:
                text = text.replace("'","\\textquotesingle")
            text = text.replace('ijkhyphenateijk','\\-')
            self.body.append(text)
#            self.body.append(text)

    def depart_Text(self, node):
        pass

    def visit_comment(self, node):
        raise nodes.SkipNode

    def visit_meta(self, node):
        # only valid for HTML
        raise nodes.SkipNode

    def visit_system_message(self, node):
        pass
    def depart_system_message(self, node):
        self.body.append('\n')

    def visit_math(self, node):
        self.body.append('$'+node['latex']+'$')

    def depart_math(self, node):
        pass
    

    def visit_displaymath(self, node):
        self.body.append('\n\n\\['+node['latex']+'\\]\n\n')

    def depart_displaymath(self, node):
        pass

    def unknown_visit(self, node):
        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)

    def visit_squeeze(self, node):
        self.body.append('SQQ')
        pass

    def depart_squeeze(self, node):
        pass

    def visit_ebnf(self, node):
        text= node[0].astext()

        indent = False
        if text.find('::=') == -1:
            if not 'inline' in node['classes']:
                node['classes'].append('inline')
                indent = True
                text = text.strip()

        if 'inline' in node['classes']:
            clauses = [text]
        else:
            clauses = [m.group(0) for m in re.finditer('(.*\s*::=((.|\n)(?!.*\s*::=))*)',text)]

        lhs = ''
        for x in re.finditer(r'^(.*)::=', text):
            name = x.groups(0)[0].strip()
            if len(name) > len(lhs):
                lhs = name

        for x in re.finditer(r'[\n|^](.*)::=', text):
            name = x.groups(0)[0].strip()
            if len(name) > len(lhs):
                lhs = name

        def make_opt(m):
            inner = m.groups(0)[0]
            if len(inner.split(' ')) > 1:
                return '!multiopt!%s!'%inner
            return '!opt!%s!'%inner

        for clause in clauses:
            clause = clause.replace('!','aaexclaimaa')
            clause = clause.replace('::=','!amp! !is! !amp!')
            clause = re.sub(r'\*one of\*\s*\n','!oneof!',clause)
            clause = clause.replace('\n','!newline!')
            clause = re.sub(r'!newline![ ]*\|','!newline! !amp! !choice! !amp!', clause)
            clause = re.sub(r'``(?P<txt>[^`]*)``','!token!\g<txt>!',clause)
            clause = re.sub(r'~~(?P<txt>[^~]*)~~','!token!\g<txt>!',clause)
            clause = re.sub(r'<(?P<txt>[^>]*)>\?',make_opt,clause)
            clause = re.sub(r'<(?P<txt>[^>]*)>\*','!star!\g<txt>!',clause)
            clause = re.sub(r'<(?P<txt>[^>]*)>\+','!plus!\g<txt>!',clause)
            clause = self.encode(clause)
            clause = clause.replace('!amp!','&')
            clause = clause.replace('!is!','\\is')
            clause = clause.replace('!newline!','\\\\ \n')
            clause = clause.replace('!choice!','\\choice')
            clause = clause.replace('!oneof!','\\oneof \\\\ &&')
            clause = re.sub(r'!token!(?P<txt>[^!]*)!','\\\\token{\g<txt>}',clause)
            clause = re.sub(r'!opt!(?P<txt>[^!]*)!','\\\\ebnf{opt}{\g<txt>}',clause)
            clause = re.sub(r'!multiopt!(?P<txt>[^!]*)!','\\\\ebnf{opt}{$\\\\langle$\g<txt>$\\\\rangle$}',clause)
            clause = re.sub(r'!star!(?P<txt>[^!]*)!','\\\\ebnf{0}{\g<txt>}',clause)
            clause = re.sub(r'!plus!(?P<txt>[^!]*)!','\\\\ebnf{1}{\g<txt>}',clause)
            clause = clause.replace('aaexclaimaa','!')
            if 'inline' in node['classes']:
                if indent:
                    self.body.append('\\begin{indentation}{\\forceindentlen}{0mm}')
                self.body.append('\\emph{')
            else:
                if 'adjustindent' in node:
                    self.body.append('\n\\begin{grammar}[%s]{%s}\n'%(node['adjustindent'],lhs))
                else:
                    self.body.append('\n\\begin{grammar}{%s}\n'%lhs)
            self.body.append(clause)
            if 'inline' in node['classes']:
                self.body.append('}')
                if indent:
                    self.body.append('\\end{indentation}')
            else:
                self.body.append('\\end{grammar}\n')

        raise nodes.SkipNode

    def depart_ebnf(self, node):
        pass

    def visit_tools_output(self, node):
        code = node.astext()
        max_line_width = max([len(x) for x in code.split('\n')])

        options=''
        if max_line_width > 65:
            options='basicstyle=\\ttfamily\\Smaller,'

        self.body.append('\\begin{lstlisting}[%srulecolor=\\color{white},backgroundcolor=\\color{white},resetmargins=true]\n'%options)
        self.body.append(node.astext())
        self.body.append('\\end{lstlisting}\n\n')
        raise nodes.SkipNode

