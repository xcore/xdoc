# -*- coding: utf-8 -*-
"""
    sphinx.writers.latex
    ~~~~~~~~~~~~~~~~~~~~

    Custom docutils writer for LaTeX.

    Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
    docutils sandbox.

    :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""

import re
import sys
import string
from os import path

from docutils import nodes, writers
from docutils.writers.latex2e import Babel

from sphinx import addnodes
from sphinx import highlighting
from sphinx.errors import SphinxError
from sphinx.locale import admonitionlabels, versionlabels, _
from sphinx.util.osutil import ustrftime
from sphinx.util.pycompat import any
from sphinx.util.texescape import tex_escape_map, tex_replace_map
from sphinx.util.smartypants import educate_quotes_latex

xmoslatex_admonitionlabels = { 'attention' : 'warn',
                               'caution' : 'warn',
                               'danger' : 'warn',
                               'error' : 'warn',
                               'hint' : 'info',
                               'important' : 'info',
                               'note' : 'info',
                               'tip' : 'info',
                               'warning' : 'info',
                               'newinxc' : 'newinxc'}


NON_XMOS_HEADER = r'''\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 

\usepackage{xdoc}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\usepackage{color}
\definecolor{lightgrey}{gray}{0.93}
\usepackage{ragged2e}
\usepackage{ifsym}
\renewcommand\thesection{\arabic{section}} 
%% Set inner and outer margins to .5 and 1 inch, respectively
\setlrmarginsandblock{1in}{1in}{*}
%% Set top and bottom margins to .8 inches
\setulmarginsandblock{.8in}{.8in}{*}
\checkandfixthelayout
\setlength{\parindent}{0cm}
\addtolength{\parskip}{0.2\baselineskip}
'''


HEADER0 = r'''%% Generated by Sphinx.
\newenvironment{commentary}{\begin{changemargin}{11mm}{0in}\begin{footnotesize}}{\end{footnotesize}\end{changemargin}}
\def\sphinxdocclass[english]{%(docclass)s}
\documentclass[%(pointsize)s %(classopts)s %(doctype)s]{%(wrapperclass)s}
%(inputenc)s
%(utf8extra)s
'''

HEADER1 = r'''
%(longtable)s

%(preamble)s

\title{%(title)s}
\date{%(date)s}
\author{%(author)s}
\newcommand{\sphinxlogo}{%(logo)s}
\newcommand{\releasename}{%(releasename)s}
\usepackage{xsphinx}
\usepackage{threeparttable}
\usepackage{fancyvrb}
\usepackage{indent}
\renewcommand\bfcode\textbf
\renewcommand\bf\textbf
\graphicspath{{./}{./images/}}
%(makeindex)s
'''

BEGIN_DOC = r'''
%(begin)s
%(shorthandoff)s
%(maketitle)s
%(toc)s
%(fullwidth)s
'''

FOOTER = r'''
\renewcommand{\indexname}{%(indexname)s}
%(printindex)s
%(enddoc)s
'''

toplevel_desc = ['function','type']

class collected_footnote(nodes.footnote):
    """Footnotes that are collected are assigned this class."""

class UnsupportedError(SphinxError):
    category = 'Markup is unsupported in LaTeX'


class XLaTeXWriter(writers.Writer):

    supported = ('sphinxlatex',)

    settings_spec = ('LaTeX writer options', '', (
        ('Document name', ['--docname'], {'default': ''}),
        ('Document class', ['--docclass'], {'default': 'collection'}),
        ('Author', ['--author'], {'default': ''}),
        ))
    settings_defaults = {}

    output = None

    def __init__(self, builder):
        writers.Writer.__init__(self)
        self.builder = builder

    def translate(self):
        visitor = LaTeXTranslator(self.document, self.builder)
        self.document.walkabout(visitor)
        self.output = visitor.astext()


# Helper classes

class ExtBabel(Babel):
    def get_shorthandoff(self):
        shortlang = self.language.split('_')[0]
        if shortlang in ('de', 'sl', 'pt', 'es', 'nl', 'pl', 'it'):
            return '\\shorthandoff{"}'
        return ''

    _ISO639_TO_BABEL = Babel._ISO639_TO_BABEL.copy()
    _ISO639_TO_BABEL['sl'] = 'slovene'


class Table(object):
    def __init__(self):
        self.col = 0
        self.colcount = 0
        self.colspec = []
        self.rowcount = 0
        self.had_head = False
        self.has_verbatim = False
        self.caption = None
        self.longtable = False
        self.prev_colcount = None


class LaTeXTranslator(nodes.NodeVisitor):
    sectionnames = ["chapter", "section", "subsection",
                    "subsubsection", "paragraph", "subparagraph"]

    ignore_missing_images = False

    default_elements = {
        'papersize':       'letterpaper',
        'pointsize':       '12pt',
        'classoptions':    '',
        'inputenc':        '\\usepackage[utf8]{inputenc}',
        'utf8extra':       '\\DeclareUnicodeCharacter{00A0}{\\nobreakspace}',
        'fontenc':         '\\usepackage[T1]{fontenc}',
        'babel':           '\\usepackage{babel}',
        'fontpkg':         '\\usepackage{times}',
        'fncychap':        '\\usepackage[Bjarne]{fncychap}',
        'longtable':       '\\usepackage{longtable}',
        'preamble':        '',
        'title':           '',
        'date':            '',
        'release':         '',
        'author':          '',
        'logo':            '',
        'releasename':     'Release',
        'makeindex':       '\\makeindex',
        'shorthandoff':    '',
        'maketitle':       '\\maketitle',
        'tableofcontents': '\\tableofcontents',
        'footer':          '',
        'printindex':      '\\printindex',
        'toc':'',
        'fullwidth':'',
    }

    def __init__(self, document, builder):
        nodes.NodeVisitor.__init__(self, document)
        self.builder = builder
        self.body = []

        # sort out some elements
        papersize = builder.config.latex_paper_size + 'paper'
        if papersize == 'paper': # e.g. command line "-D latex_paper_size="
            papersize = 'letterpaper'

        self.elements = self.default_elements.copy()
        if self.builder.config.latex_toc:
            toc = '\\toc\n'
        else:
            toc = ''

        if self.builder.config.latex_doctype == 'collection':
            fullwidth = '\\begin{fullwidth} %preface\n'
        else:
            fullwidth = ''

        if builder.config.use_xmoslatex:
            begin = '\\start'
            enddoc = '\\finish'
        else:
            begin = '\\begin{document}'
            enddoc = '\\end{document}'

        self.seen_first_title = False
        self.elements.update({
            'wrapperclass': builder.config.latex_docclass,
            'doctype': builder.config.latex_doctype,
            'papersize':    papersize,
            'pointsize':    builder.config.latex_font_size ,
            # if empty, the title is set to the first section title
            'title':        document.settings.title,
            'release':      builder.config.release,
            'author':       document.settings.author,
            'releasename':  _('Release'),
            'preamble':     builder.config.latex_preamble,
            'toc' : toc,
            'fullwidth': fullwidth,
            'indexname':    _('Index'),
            'begin':begin,
            'enddoc':enddoc
        })

        if builder.config.use_xmoslatex:
            self.elements['classopts'] = ''
        else:
            self.elements['classopts'] = 'a4paper, oneside, '



        document.settings.docclass = builder.config.latex_docclass


        # if document.settings.docclass == 'howto':
        #     docclass = builder.config.latex_docclass.get('howto', 'article')
        # else:
        #     docclass = builder.config.latex_docclass.get('collection', 'report')
        
        self.elements['docclass'] = builder.config.latex_docclass

        if builder.config.today:
            self.elements['date'] = builder.config.today
        else:
            self.elements['date'] = ustrftime(builder.config.today_fmt
                                              or _('%B %d, %Y'))
        if builder.config.latex_logo:
            self.elements['logo'] = '\\includegraphics{%s}\\par' % \
                                    path.basename(builder.config.latex_logo)
        if builder.config.language:
            babel = ExtBabel(builder.config.language)
            lang = babel.get_language()
            if lang:
                self.elements['classoptions'] += ',' + babel.get_language()
            else:
                self.builder.warn('no Babel option known for language %r' %
                                  builder.config.language)
            self.elements['shorthandoff'] = babel.get_shorthandoff()
            self.elements['fncychap'] = '\\usepackage[Sonny]{fncychap}'
        else:
            self.elements['classoptions'] += ',english'
        # allow the user to override them all
        self.elements.update(builder.config.latex_elements)

        self.highlighter = highlighting.PygmentsBridge('latex',
            builder.config.pygments_style, builder.config.trim_doctest_flags)
        self.context = []
        self.descstack = []
        self.bibitems = []
        self.table = None
        self.next_table_colspec = None
        # stack of [language, linenothreshold] settings per file
        # the first item here is the default and must not be changed
        # the second item is the default for the master file and can be changed
        # by .. highlight:: directive in the master file
        self.hlsettingstack = 2 * [[builder.config.highlight_language,
                                    sys.maxint]]
        self.footnotestack = []
        self.curfilestack = []
        self.in_footnote = False
        self.handled_abbrs = set()

        if document.settings.docclass == 'howto':
            self.top_sectionlevel = 2
        else:
            if builder.config.latex_use_parts:
                self.top_sectionlevel = 0
            elif builder.config.latex_use_chapters:
                self.top_sectionlevel = 0
            else:
                self.top_sectionlevel = 1
        self.next_section_ids = set()
        self.next_figure_ids = set()
        self.next_table_ids = set()
        # flags
        self.verbatim = None
        self.in_title = 0
        self.in_production_list = 0
        self.first_document = 1
        self.this_is_the_title = 1
        self.literal_whitespace = 0
        self.no_contractions = 0
        self.compact_list = 0
        self.first_param = 0
        self.fullwidth = False
        self.in_reference = False
        self.next_title_indent = False
        self.next_title_fullwidth = False
        self.section_summary_fullwidth = False
        self.in_subscript = False
        self.in_sig = False

    def astext(self):
        text = HEADER0 % self.elements
        if not self.builder.config.use_xmoslatex:
            text = text + NON_XMOS_HEADER % self.elements
        text = text + HEADER1 % self.elements
        text = text + self.highlighter.get_stylesheet() + \
                u''.join(self.body) + \
                '\n' + self.elements['footer'] + '\n' + \
                self.generate_indices() + \
                FOOTER % self.elements
        return text

    def hypertarget(self, id, withdoc=True, anchor=True):
        if withdoc:
            id = self.curfilestack[-1] + ':' + id
        return (anchor and '\\phantomsection' or '') + \
               '\\label{%s}' % self.idescape(id)

    def hyperlink(self, id):
#        self.no_emph = 1


        if id.find('sec-') != -1:
            return '\Sec~\\ref{%s}{{' % (self.idescape(id))
        else:
            return '{\\hyperref[%s]{' % (self.idescape(id))

    def hyperpageref(self, id):
        return '\\autopageref*{%s}' % (self.idescape(id))

    def idescape(self, id):
        return str(unicode(id).translate(tex_replace_map))

    def generate_indices(self):
        def generate(content, collapsed):
            ret.append('\\begin{theindex}\n')
            ret.append('\\def\\bigletter#1{{\\Large\\sffamily#1}'
                       '\\nopagebreak\\vspace{1mm}}\n')
            for i, (letter, entries) in enumerate(content):
                if i > 0:
                    ret.append('\\indexspace\n')
                ret.append('\\bigletter{%s}\n' %
                           letter.translate(tex_escape_map))
                for entry in entries:
                    if not entry[3]:
                        continue
                    ret.append('\\item {\\texttt{%s}}' % self.encode(entry[0]))
                    if entry[4]:
                        # add "extra" info
                        ret.append(' \\emph{(%s)}' % self.encode(entry[4]))
                    ret.append(', \\pageref{%s:%s}\n' %
                               (entry[2], self.idescape(entry[3])))
            ret.append('\\end{theindex}\n')

        ret = []
        # latex_domain_indices can be False/True or a list of index names
        indices_config = self.builder.config.latex_domain_indices
        if indices_config:
            for domain in self.builder.env.domains.itervalues():
                for indexcls in domain.indices:
                    indexname = '%s-%s' % (domain.name, indexcls.name)
                    if isinstance(indices_config, list):
                        if indexname not in indices_config:
                            continue
                    # deprecated config value
                    if indexname == 'py-modindex' and \
                           not self.builder.config.latex_use_modindex:
                        continue
                    content, collapsed = indexcls(domain).generate(
                        self.builder.docnames)
                    if not content:
                        continue
                    ret.append(u'\\renewcommand{\\indexname}{%s}\n' %
                               indexcls.localname)
                    generate(content, collapsed)

        return ''.join(ret)

    def visit_document(self, node):
        self.footnotestack.append(self.collect_footnotes(node))
        self.curfilestack.append(node.get('docname', ''))
        if self.first_document == 1:
            # the first document is all the regular content ...
            self.body.append(BEGIN_DOC % self.elements)
            self.first_document = 0
        elif self.first_document == 0:
            # ... and all others are the appendices
            self.body.append(u'\n\\appendix\n')
            self.first_document = -1
        if node.has_key('docname'):
            self.body.append(self.hypertarget(':doc'))
        # "- 1" because the level is increased before the title is visited
        self.sectionlevel = self.top_sectionlevel - 1
        self.section_summary = []

        for p in node.traverse(nodes.paragraph):
            p['margin_items'] = []

        if self.builder.config.latex_doctype != 'collection':
            self.section_summary_pos = len(self.body)+2


    def depart_document(self, node):

        if self.section_summary != []:
            summary = "\\begin{inthisdocument}\n"
            for item in self.section_summary:
                summary += "\item %s\n"%item
            summary += "\\end{inthisdocument}\n\n"
            if self.section_summary_fullwidth:
                summary += '\\begin{fullwidth} % chapter\n'

            self.body.insert(self.section_summary_pos, summary)

        if self.builder.config.latex_doctype == 'collection':
            if not self.seen_first_title:
                self.seen_first_title = True
                self.body.append('\\end{fullwidth}\n')



        if False and self.bibitems:
            widest_label = ""
            for bi in self.bibitems:
                if len(widest_label) < len(bi[0]):
                    widest_label = bi[0]
            self.body.append(u'\n\\begin{thebibliography}{%s}\n' % widest_label)
            for bi in self.bibitems:
                target = self.hypertarget(bi[2] + ':' + bi[0].lower(),
                                          withdoc=False)
                self.body.append(u'\\bibitem[%s]{%s}{%s %s}\n' %
                    (bi[0], self.idescape(bi[0]), target, bi[1]))
            self.body.append(u'\\end{thebibliography}\n')
            self.bibitems = []

    def visit_start_of_file(self, node):
        # collect new footnotes
        self.footnotestack.append(self.collect_footnotes(node))
        # also add a document target
        self.next_section_ids.add(':doc')
        self.curfilestack.append(node['docname'])
        # use default highlight settings for new file
        self.hlsettingstack.append(self.hlsettingstack[0])

    def collect_footnotes(self, node):
        fnotes = {}
        def footnotes_under(n):
            if isinstance(n, nodes.footnote):
                yield n
            else:
                for c in n.children:
                    if isinstance(c, addnodes.start_of_file):
                        continue
                    for k in footnotes_under(c):
                        yield k
        for fn in footnotes_under(node):
            num = fn.children[0].astext().strip()
            fnotes[num] = [collected_footnote(*fn.children), False]
        return fnotes

    def depart_start_of_file(self, node):
        self.footnotestack.pop()
        self.curfilestack.pop()
        self.hlsettingstack.pop()

    def visit_highlightlang(self, node):
        self.hlsettingstack[-1] = [node['lang'], node['linenothreshold']]
        raise nodes.SkipNode

    def visit_section(self, node):
        if 'xc-spec' in node['classes']:
            self.body.append('\\begin{spec}')
        if not self.this_is_the_title:
            self.sectionlevel += 1
        self.body.append('\n\n')
        if node.get('ids'):
            self.next_section_ids.update(node['ids'])
        if 'testplan_item' in node['classes']:
            self.next_title_indent = True

        if not self.fullwidth:
          if self.builder.config.latex_doctype != 'collection' or self.sectionlevel == self.top_sectionlevel:
            for n in node.traverse():
                has_toplevel_desc = \
                    isinstance(n, addnodes.desc) and \
                    (n['desctype'] in toplevel_desc)
                tp_item = isinstance(n, nodes.section) and \
                    'testplan_item' in n['classes']
                if not 'not-fullwidth' in node['classes']:
                  if (has_toplevel_desc or
                      tp_item or
                      'fullwidth' in node['classes']):
                    self.fullwidth = True
                    if self.builder.config.latex_doctype != 'collection':
                        self.section_summary_fullwidth = True
#                        self.body.append('\\begin{fullwidth} % fragment')
                    else:
                        self.body.append('\n% FULLWIDTH SECTION\n')
                    node['started_fullwidth'] = True
                    break

    def depart_section(self, node):
        self.sectionlevel = max(self.sectionlevel - 1,
                                self.top_sectionlevel - 1)


        if 'testplan_item' in node['classes']:
            self.body.append('\\end{indentation}')
        if 'started_fullwidth' in node:
            self.body.append('\\end{fullwidth}')
            self.fullwidth = False
        if 'xc-spec' in node['classes']:
            self.body.append('\\end{spec}')

    def visit_problematic(self, node):
        self.body.append(r'{\color{red}\bfseries{}')
    def depart_problematic(self, node):
        self.body.append('}')

    def visit_topic(self, node):
        self.body.append('\\setbox0\\vbox{\n'
                         '\\begin{minipage}{0.95\\linewidth}\n')
    def depart_topic(self, node):
        self.body.append('\\end{minipage}}\n'
                         '\\begin{center}\\setlength{\\fboxsep}{5pt}'
                         '\\shadowbox{\\box0}\\end{center}\n')
    visit_sidebar = visit_topic
    depart_sidebar = depart_topic

    def visit_glossary(self, node):
        pass
    def depart_glossary(self, node):
        pass

    def visit_productionlist(self, node):
        self.body.append('\n\n\\begin{productionlist}\n')
        self.in_production_list = 1
    def depart_productionlist(self, node):
        self.body.append('\\end{productionlist}\n\n')
        self.in_production_list = 0

    def visit_production(self, node):
        if node['tokenname']:
            self.body.append('\\production{%s}{' %
                             self.encode(node['tokenname']))
        else:
            self.body.append('\\productioncont{')
    def depart_production(self, node):
        self.body.append('}\n')

    def visit_transition(self, node):
        self.body.append('\n\n\\bigskip\\hrule{}\\bigskip\n\n')
    def depart_transition(self, node):
        pass

    def visit_title(self, node):
        parent = node.parent
        if isinstance(parent, addnodes.seealso):
            # the environment already handles this
            raise nodes.SkipNode
        elif self.this_is_the_title:
            if len(node.children) != 1 and not isinstance(node.children[0],
                                                          nodes.Text):
                self.builder.warn(
                    'document title is not a single Text node',
                    '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                               node.line or ''))
            if not self.elements['title']:
                # text needs to be escaped since it is inserted into
                # the output literally
                self.elements['title'] = node.astext().translate(tex_escape_map)
            self.this_is_the_title = 0
            raise nodes.SkipNode
        elif isinstance(parent, nodes.section):
            if not self.builder.config.latex_section_numbers or \
               'nosecnum' in node['classes']:
                modifier = '*'
            else:
                modifier = ''
            try:
                if self.builder.config.latex_doctype == 'collection':
                    if not self.seen_first_title:
                        self.seen_first_title = True
                        self.body.append('\\end{fullwidth}\n')

                if (self.builder.config.latex_section_newpage):
                    if (self.sectionlevel <= self.top_sectionlevel):
                        self.body.append('\\clearpage\n');
                if 'compact' in node['classes']:
                    self.body.append('\n\\vspace{-\\parsep}\n')

                self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel],modifier))
            except IndexError:
                indent = ""
                for i in range(1 + self.sectionlevel - len(self.sectionnames)):
                    indent += "\ \ "
                # just use "subparagraph", it's not nu mbered anyway
                self.body.append(r'\%s%s{' % (self.sectionnames[-1],modifier))
                self.body.append(indent)
            self.context.append('}\n')

            if self.next_section_ids:
                for id in self.next_section_ids:
                    self.context[-1] += self.hypertarget(id, anchor=False)
                self.next_section_ids.clear()

        elif isinstance(parent, (nodes.topic, nodes.sidebar)):
            self.body.append(r'\textbf{')
            self.context.append('}\n\n\medskip\n\n')
        elif isinstance(parent, nodes.Admonition):
            self.body.append('{')
            self.context.append('}\n')
        elif isinstance(parent, nodes.table):
            self.table.caption = self.encode(node.astext())
            raise nodes.SkipNode
        else:
            self.builder.warn(
                'encountered title node not in section, topic, table, '
                'admonition or sidebar',
                '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                           node.line or ''))
            self.body.append('\\textbf{')
            self.context.append('}\n')
        self.in_title = 1

        if self.builder.config.use_xmoslatex:
            if self.builder.config.latex_doctype == 'collection':
                tp = self.top_sectionlevel
            else:
                tp = self.top_sectionlevel - 1
            if self.builder.config.latex_doctype == 'collection' and \
               self.sectionlevel == tp:

                if self.section_summary != []:
                    summary = "\\begin{inthisdocument}\n"
                    for item in self.section_summary:
                        summary += "\item %s\n"%item
                    summary += "\\end{inthisdocument}\n\n"

                    if self.section_summary_fullwidth:
                        summary += '\\begin{fullwidth} % chapter\n'

                    self.body.insert(self.section_summary_pos, summary)
                self.section_summary = []
                self.section_summary_fullwidth = self.fullwidth

                self.section_summary_pos = len(self.body)+2
            if self.sectionlevel == tp+1:
                self.section_summary_entry_pos = len(self.body)
#                self.section_summary.append(str(node[0]))

    def depart_title(self, node):
        if self.builder.config.use_xmoslatex:
            if self.builder.config.latex_doctype == 'collection':
                tp = self.top_sectionlevel + 1
            else:
                tp = self.top_sectionlevel
            if self.sectionlevel == tp:
                item = ''
                for x in self.body[self.section_summary_entry_pos:]:
                    item += x
                self.section_summary.append(item)

        self.in_title = 0
        self.body.append(self.context.pop())
        if 'compact' in node['classes']:
            self.body.append('\n\\vspace{-\\parsep}\n')
        if self.next_title_indent:
            self.nexst_title_indent = False
            self.body.append('\\begin{indentation}{\\blockindentlen}{0mm}')


    def visit_subtitle(self, node):
        if isinstance(node.parent, nodes.sidebar):
            self.body.append('~\\\\\n\\textbf{')
            self.context.append('}\n\\smallskip\n')
        else:
            self.context.append('')
    def depart_subtitle(self, node):
        self.body.append(self.context.pop())

    def visit_desc_list(self, node):
        if self.builder.config.use_xmoslatex:
            desctype = None
            for x in node.traverse(addnodes.desc):
                desctype = x['desctype']
                break
            node['desctype'] = desctype
            if desctype in toplevel_desc:
                pass
            elif desctype != None:
                self.body.append('\\begin{option}\n\n')
            else:
                pass
#                print node

    def depart_desc_list(self, node):
        if self.builder.config.use_xmoslatex:
            desctype = node['desctype']
            if desctype in toplevel_desc:
                pass
            elif desctype != None:
                self.body.append('\\end{option}\n\n')

    def visit_desc(self, node):
        if not self.builder.config.use_xmoslatex:
            self.body.append('\n\n\\begin{fulllineitems}\n')
        else:
            if node['desctype'] in toplevel_desc:
                estimated_param_len = 0
                for y in node.traverse(addnodes.desc_signature):
                    for x in y.traverse(nodes.Text):
                        estimated_param_len += len(str(x))
                if self.fullwidth:
                    long_params = estimated_param_len > 70
                else:
                    long_params = estimated_param_len > 65
                node['long_params'] = long_params
                for x in node.traverse(addnodes.desc_parameter):
                    x['long_params'] = long_params
                if long_params:
                    self.body.append('\n\\vspace{-1.5\\baselineskip}')
                self.body.append('\n\n\\texttt{')
                if long_params:
                    self.body.append('\\begin{tabbing}')

    def depart_desc(self, node):
        if not self.builder.config.use_xmoslatex:
            self.body.append('\n\\end{fulllineitems}\n\n')





    def visit_desc_signature(self, node):
        node['desctype'] = node.parent['desctype']
        if node.parent['objtype'] != 'describe' and node['ids']:
            hyper = self.hypertarget(node['ids'][0])
        else:
            hyper = ''
        self.body.append(hyper)
        if self.builder.config.use_xmoslatex:
            self.prev_duplicate_sig = False
            if not node.parent['desctype'] in toplevel_desc:
                self.body.append('\\item[')
        else:
            params = False
            for child in node:
                if isinstance(child, addnodes.desc_parameterlist):
                    params = True
                    break
            if params:
                self.body.append(r'\pysiglinewithargsret{')
            else:
                self.body.append(r'\pysigline{')
        self.in_sig = True


    def depart_desc_signature(self, node):
        if self.builder.config.use_xmoslatex:
            if not node.parent['desctype'] in toplevel_desc:
                self.body.append(r']')
                if self.prev_duplicate_sig:
                    self.body.append('\duplicateoption')
        else:
            self.body.append(r'}{} \justifying \setlength{\parindent}{0mm}')
        self.in_sig = False

    def visit_desc_addname(self, node):
        if self.builder.config.use_xmoslatex:
            self.body.append(r'\optemph{')
        else:
            self.body.append(r'\code{')
        self.literal_whitespace += 1

    def depart_desc_addname(self, node):
        self.body.append('}')
        self.literal_whitespace -= 1

    def visit_desc_type(self, node):
        pass
    def depart_desc_type(self, node):
        pass

    def visit_desc_returns(self, node):
        self.body.append(r'}{ $\rightarrow$ ')
    def depart_desc_returns(self, node):
        pass

    def visit_desc_name(self, node):
        if self.builder.config.use_xmoslatex:
            if 'duplicate' in node['classes']:
                if not node.parent['desctype'] in toplevel_desc:
                    self.body.append(" ]")
                    if self.prev_duplicate_sig:
                        self.body.append('\duplicateoption')
                    self.body.append("\n\\item[")
                    self.prev_duplicate_sig = True
        else:
            self.body.append(r'\bfcode{')
        self.literal_whitespace += 1
    def depart_desc_name(self, node):
        if self.builder.config.use_xmoslatex:
            pass
        else:
            self.body.append('}')
        self.literal_whitespace -= 1

    def visit_desc_parameterlist(self, node):
        if self.builder.config.use_xmoslatex:
            self.body.append('(')
        else:
            self.body.append('}{\\raggedright ')
        self.first_param = 1
    def depart_desc_parameterlist(self, node):
        if self.builder.config.use_xmoslatex:
            self.body.append(')')

    def visit_desc_parameter(self, node):
        if not self.first_param:
            if self.builder.config.use_xmoslatex:
                if 'long_params' in node and node['long_params']:
                    self.body.append(',\\\\ \n\\> ')
                else:
                    self.body.append(', ')
            else:
                self.body.append(',\\\\ ')
        else:
            if self.builder.config.use_xmoslatex:
                if 'long_params' in node and node['long_params']:
                    self.body.append('\\= ')
            self.first_param = 0
        if not self.builder.config.use_xmoslatex and \
           not node.hasattr('noemph'):
            self.body.append(r'\emph{')

    def depart_desc_parameter(self, node):
        if not self.builder.config.use_xmoslatex and \
           not node.hasattr('noemph'):
            self.body.append('}')

    def visit_desc_optional(self, node):
        self.body.append(r'\optional{')
    def depart_desc_optional(self, node):
        self.body.append('}')

    def visit_desc_annotation(self, node):
        self.body.append(r'\strong{')
    def depart_desc_annotation(self, node):
        self.body.append('}')

    def visit_desc_content(self, node):
        if self.builder.config.use_xmoslatex:
            if node.parent['desctype'] in toplevel_desc:
                if node.parent['long_params']:
                    self.body.append('\n\\end{tabbing}')
                    if len(node.children) == 0:
                        self.body.append('\\vspace{-3mm}\n')

                if self.fullwidth:
                    indent = '\\blockindentlen'
                else:
                    indent = '\\blockindentlen'
                self.body.append('}\n\n')

                self.body.append('\\vspace{-2mm}\n')
                self.body.append('\\sloppy\n')
                if len(node.children) != 0:
                    self.body.append('\\begin{indentation}{%s}{0mm}'%indent)
                else:
                    for x in node.parent.traverse(
                        condition=lambda x: not isinstance(x, addnodes.index),
                        include_self=False,
                        descend=False,
                        ascend=False,
                        siblings=True):
                        if isinstance(x, addnodes.desc):
                            # immediately followed by another desc
                            self.body.append('\n\\vspace{-0.25\\baselineskip}\n')
                        break
        else:
            if node.children and \
               not isinstance(node.children[0], nodes.paragraph):
                # avoid empty desc environment which causes a formatting bug
                self.body.append('~')
    def depart_desc_content(self, node):
        if self.builder.config.use_xmoslatex:
            if node.parent['desctype'] in toplevel_desc:
                if len(node.children) != 0:
                    self.body.append('\n\\end{indentation}\n')
                    #self.body.append('\\vspace{u3mm}\n')
                self.body.append('\\fussy\n')

    def visit_refcount(self, node):
        self.body.append("\\emph{")
    def depart_refcount(self, node):
        self.body.append("}\\\\")

    def visit_seealso(self, node):
        self.body.append(u'\n\n\\strong{%s:}\n\n' % admonitionlabels['seealso'])
    def depart_seealso(self, node):
        self.body.append("\n\n")

    def visit_rubric(self, node):
        if len(node.children) == 1 and node.children[0].astext() in \
               ('Footnotes', _('Footnotes')):
            raise nodes.SkipNode
        self.body.append('\\paragraph*{')
        self.context.append('}\n')
    def depart_rubric(self, node):
        self.body.append(self.context.pop())

    def visit_footnote(self, node):
        raise nodes.SkipNode

    def visit_collected_footnote(self, node):
        self.in_footnote = True
        self.body.append('\\footnote{')
    def depart_collected_footnote(self, node):
        self.in_footnote = False
        self.body.append('}')

    def visit_label(self, node):
        if isinstance(node.parent, nodes.citation):
            self.bibitems[-1][0] = node.astext()
            self.bibitems[-1][2] = self.curfilestack[-1]
#            print self.bibitems[-1][1]
            target = self.hypertarget(self.curfilestack[-1] + ':' + node.astext(),
                                      withdoc=False)
#        raise nodes.SkipNode

    def depart_label(self, node):
        pass

    def visit_tabular_col_spec(self, node):
        self.next_table_colspec = node['spec']
        raise nodes.SkipNode

    def visit_table(self, node):
        if 'pdf-no-border' in node['classes'] or 'no-border' in node['classes']:
            self.hline = ''
        else:
            self.hline = '\\hline'


        if self.table:
            raise UnsupportedError(
                '%s:%s: nested tables are not yet implemented.' %
                (self.curfilestack[-1], node.line or ''))
        self.table = Table()
        self.table.longtable = 'longtable' in node['classes']
        self.tablebody = []

        self.table.simple = True

        for child in node.traverse():
            if isinstance(child, nodes.literal_block) or \
               isinstance(child, nodes.field_list) or \
               isinstance(child, nodes.bullet_list):
                self.table.simple = False

        max_width = 0
        self.table.max_width_col = 0
        for row in node.traverse(nodes.row):
            colnum = 0
            for col in row.traverse(nodes.entry):
                text = col.astext()
                if len(text) > max_width:
                    max_width = len(text)
                    self.table.max_width_col = colnum
                colnum=colnum+1

#        self.table.simple = 'simple-content' in node['classes']

        self.table.vertical_borders = 'vertical-borders' in node['classes']
        self.table.horizontal_borders = 'horizontal-borders' in node['classes']

        self.table.no_hlines = not self.table.horizontal_borders



        if self.table.horizontal_borders:
            self.table.hline = '\\hline'
        else:
            self.table.hline = ''

        if self.table.vertical_borders:
            self.table.linesep = '|'
        else:
            self.table.linesep = ''

#        if self.builder.config.latex_doctype == 'collection':
            linesep = ''
        # Redirect body output until table is finished.
        self._body = self.body
        self.body = self.tablebody
        for cs in node.traverse(nodes.colspec):
            self.table.colcount +=1
            self.table.colspec.append(cs.attributes['colwidth'])
        self.table.skipcols = [0 for x in range(self.table.colcount)]

    def depart_table(self, node):
        linesep = self.table.linesep
        hline = self.table.hline
        if self.table.rowcount > 30:
            self.table.longtable = True
        self.body = self._body
        self.body.append("\\renewcommand{\\tabcolsep}{1.25mm}\n")
        self.body.append("\\renewcommand{\\arraystretch}{1.25}\n")

        if not self.table.longtable and self.table.caption is not None:
            if self.builder.config.use_sidecaption:
                self.body.append(u'\n\\begin{figure}[H]')
                if self.fullwidth:
                    self.body.append(u'\n\\begin{fullwidth}')
                self.body.append(u'\\begin{sidecaption}{%s}\n'%self.table.caption)
#                self.body.append(u'\\begin{minipage}{\\textwidth}\n')
                self.body.append(u'\small')
            else:
                self.body.append(u'\n\\begin{center}\\begin{threeparttable}\n')
#                             u'\\capstart\\caption{%s}\n' % self.table.caption)
#                             u'\\caption{%s}\n' % self.table.caption)

#        self.body.append('\\begin{center}')

        if self.table.longtable:
            self.body.append('\n\\begin{longtable}')
        elif self.table.has_verbatim:
            self.body.append('\n\\begin{tabular}')
        else:
            self.body.append('\n\\begin{tabularx}{\linewidth}')
#            self.body.append('\n\\begin{center}\\begin{tabulary}{\\linewidth}')
        if self.table.colspec:
            total = float(sum(self.table.colspec))
            colspec_str = ''
            for i in range(len(self.table.colspec)):
                colwidth = self.table.colspec[i]
                colwidth = (colwidth / total)
                if self.table.simple:
                    if i == self.table.max_width_col:
                        colspec_str += 'Y%s' % (linesep)
                    else:
                        colspec_str += 'l%s' % (linesep)
                else:
                    colspec_str += 'p{%.3f\\linewidth}%s' % (colwidth,linesep)
            self.body.append('{%s'%linesep + colspec_str + '}\n')
        else:
#            print node
            if self.table.has_verbatim:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{%s'%linesep + colspec + '}\n')
            elif self.table.longtable:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{|' + colspec + '}\n')
#                self.body.append('{|' + ('l|' * self.table.colcount) + '}\n')
            else:
                colwidth = 1.0 / self.table.colcount
                colspec = ('p{%.3f\\linewidth}%s' % (colwidth,linesep)) * \
                          self.table.colcount
                self.body.append('{%s'%linesep + colspec + '}\n')
#                self.body.append('{|' + ('l|' * self.table.colcount) + '}\n')
#        if self.table.longtable and self.table.caption is not None:
#            self.body.append(u'\\capstart\\caption{%s} \\\\\n' %
#                             self.table.caption)
        if self.table.caption is not None:
            for id in self.next_table_ids:
                self.body.append(self.hypertarget(id, anchor=False))
            self.next_table_ids.clear()
        if self.table.longtable:
            self.body.append('%sn'%hline)
            self.body.append('\\endfirsthead\n\n')
            self.body.append('\\multicolumn{%s}{c}%%\n' % self.table.colcount)
            self.body.append(r'{{\bfseries \tablename\ \thetable{} -- %s}} \\'
                             % _('continued from previous page'))
            self.body.append('\n%s\n'%hline)
            self.body.append('\\endhead\n\n')
            self.body.append(ur'%s \multicolumn{%s}{%sr%s}{{%s}} \\ %s'
                             % (hline, linesep, linesep,self.table.colcount,
                                _('Continued on next page'),hline))
            self.body.append('\n\\endfoot\n\n')
            self.body.append('%s\n'%hline)
            self.body.append('\\endlastfoot\n\n')
        else:
            self.body.append('\\Hline\n')
            #self.body.append('%s\n'%hline)
        self.body.extend(self.tablebody)
        if self.table.longtable:
            self.body.append('\\end{longtable}\n\n')
        elif self.table.has_verbatim:
            self.body.append('\\end{tabular}\n\n')
        else:
            self.body.append('\\end{tabularx}\n\n')

#        self.body.append('\\end{center}')

        if not self.table.longtable and self.table.caption is not None:
            if self.builder.config.use_sidecaption:
#                self.body.append(u'\\end{minipage}')
                self.body.append(u'\\end{sidecaption}\n')
                if self.fullwidth:
                    self.body.append(u'\n\\end{fullwidth}')
                self.body.append('\\end{figure}\n')
            else:
                self.body.append(u'\\caption{%s}\n' % self.table.caption)
                self.body.append('\\end{threeparttable}\n\n\\end{center}\n\n')
        self.table = None
        self.tablebody = None

    def visit_colspec(self, node):
        pass
 
    def depart_colspec(self, node):
        pass

    def visit_tgroup(self, node):
        pass
    def depart_tgroup(self, node):
        pass

    def visit_thead(self, node):
        if self.next_table_colspec:
            self.table.colspec = '{%s}\n' % self.next_table_colspec
        self.next_table_colspec = None
#        self.body.append('\\hline\n')
#        self.table.had_head = True
    def depart_thead(self, node):
        self.body.append('%s\n'%self.hline)

    def visit_tbody(self, node):
        if not self.table.had_head:
            self.visit_thead(node)
    def depart_tbody(self, node):
        self.body.append('%s\n'%self.hline)

    def visit_row(self, node):
#        for c in node.children:
#            print c
#            if node.has_key('morecols'):
#                print "mc: %d" % node['morecols']
#           else:
#                print 0
#        print self.table.colcount
#        print len(node.children)
        colcount = len(node.children)
        spanning_header = (self.table.prev_colcount != self.table.colcount and \
                           self.table.prev_colcount == 1) 



        if not self.table.no_hlines:
         if spanning_header or \
                (self.table.prev_colcount != None and \
                 colcount != self.table.prev_colcount):
            for i in range(self.table.colcount):
                if self.table.skipcols[i] == 0:
                    self.body.append('\\cline{%d-%d}\n'%(i+1,i+1))

#        self.body.append('\hline\n')

        self.table.prev_colcount = colcount
        # if (self.table.colcount != colcount):
        #     colwidth = 0.90 / colcount
        #     colspec = ('p{%.3f\\linewidth}%s' % (colwidth,self.linesep)) * colcount
        #     self.body.append('\\multicolumn{%d}' % self.table.colcount)
        #     self.body.append('{%s'%self.linesep + colspec + '}{')
        self.table.col = 0

        found_content = False
        for x in node.traverse(nodes.paragraph):
            found_content = True

        if not found_content and not self.table.horizontal_borders:
            self.body.append('\\hline\n')
            raise nodes.SkipNode

    def depart_row(self, node):
#        if (self.table.colcount != len(node.children)):
#            self.body.append('}')
        while self.table.col < self.table.colcount and self.table.skipcols[self.table.col] > 0:
            self.table.skipcols[self.table.col] = self.table.skipcols[self.table.col]-1
            self.table.col += 1
            self.body.append(' & ')

        self.body.append('\\\\\n')
#        if (self.table.colcount != len(node.children)):
#            self.body.append('\hline\n')
        self.table.rowcount += 1

    def visit_entry(self, node):
        # if node.has_key('morerows'):
        #     raise UnsupportedError('%s:%s: row spanning cells are '
        #                            'not yet implemented.' %
        #                            (self.curfilestack[-1], node.line or ''))
        if node.has_key('morecols') and node.has_key('morerows'):
             raise UnsupportedError('%s:%s: ceels that span columns and rows'
                                    ' are not yet implemented.' %
                                    (self.curfilestack[-1], node.line or ''))

        while self.table.skipcols[self.table.col] > 0:
            self.table.skipcols[self.table.col] = self.table.skipcols[self.table.col]-1
            if self.table.col > 0:
                self.body.append(' & ')
            self.table.col += 1


        if self.table.col > 0:
            self.body.append(' & ')
        if node.has_key('morecols'):
            n = int(node['morecols'])+1
            total = float(sum(self.table.colspec))
            colwidth = float(sum(self.table.colspec[self.table.col:self.table.col+n]))
            colwidth = (colwidth / total)
            if self.table.col == 0:
                init_div=self.table.linesep
            else:
                init_div=''
            if self.table.col+n == len(self.table.colspec):
                final_div=self.table.linesep
            else:
                final_div=''
            if self.table.simple:
                self.body.append('\\multicolumn{%d}{%sl%s}{' % (n,init_div,final_div) )
            else:
                self.body.append('\\multicolumn{%d}{%sp{%.3f\linewidth}%s}{' % (n,init_div,colwidth,final_div) )

#            self.context.append('}')

        if node.has_key('morerows'):
            n = int(node['morerows'])+1
            total = float(sum(self.table.colspec))
            colwidth = float(self.table.colspec[self.table.col])
            colwidth = (colwidth / total) * 1.0
#            self.body.append('\multirow{%d}{%.3f\linewidth}{' % (n,colwidth) )
            self.table.skipcols[self.table.col] += n-1

        self.table.col += 1
        if isinstance(node.parent.parent, nodes.thead):
            self.body.append('\\textbf{')
            self.context.append('}')
        else:
            self.context.append('')

    def depart_entry(self, node):
        if node.has_key('morecols'):
            self.body.append('}')
        if node.has_key('morerows'):
            pass
#            self.body.append('}')

        self.body.append(self.context.pop()) # header

    def visit_acks(self, node):
        # this is a list in the source, but should be rendered as a
        # comma-separated list here
        self.body.append('\n\n')
        self.body.append(', '.join(n.astext()
                                   for n in node.children[0].children) + '.')
        self.body.append('\n\n')
        raise nodes.SkipNode

    def visit_bullet_list(self, node):
        if not self.compact_list:
            if 'nopoints' in node['classes']:
                self.body.append('\\begin{nopoints}\n' )
            else:
                self.body.append('\\begin{itemize}\n' )



    def depart_bullet_list(self, node):
        if not self.compact_list:
            if 'nopoints' in node['classes']:
                self.body.append('\\end{nopoints}\n' )
            else:
                self.body.append('\\end{itemize}\n' )


    def visit_enumerated_list(self, node):
        if 'steps' in node['classes']:
            self.body.append('\\begin{steps}\n' )
        else:
            self.body.append('\\begin{enumerate}\n' )
        if 'start' in node:
            self.body.append('\\setcounter{enumi}{%d}\n' % (node['start'] - 1))
    def depart_enumerated_list(self, node):
        if 'steps' in node['classes']:
            self.body.append('\\end{steps}\n' )
        else:
            self.body.append('\\end{enumerate}\n' )

    def visit_list_item(self, node):
        # Append "{}" in case the next character is "[", which would break
        # LaTeX's list environment (no numbering and the "[" is not printed).
        self.body.append(r'\item {  ')
    def depart_list_item(self, node):
        self.body.append('}\n')

    def visit_definition_list(self, node):
#        self.body.append('\\begin{description}\n')
        pass
    def depart_definition_list(self, node):
#        self.body.append('\\end{description}\n')
        pass

    def visit_definition_list_item(self, node):
        pass
    def depart_definition_list_item(self, node):
        pass

    def visit_term(self, node):
#        ctx = '}] \\leavevmode'
        ctx = ''
        if node.has_key('ids') and node['ids']:
            ctx += self.hypertarget(node['ids'][0])
#        self.body.append('\\item[{')
        self.context.append(ctx)
    def depart_term(self, node):
        self.body.append(self.context.pop())

    def visit_classifier(self, node):
        self.body.append('{[}')
    def depart_classifier(self, node):
        self.body.append('{]}')

    def visit_definition(self, node):
        pass
    def depart_definition(self, node):
        self.body.append('\n')

    def visit_field_list(self, node):
        self.body.append('\n\n')
        if 'actions' in node['classes']:
#            self.body.append('\\begin{actions}\n\n')
            for f in node.traverse(nodes.field):
                f['classes'].append('action')
            for f in node.traverse(nodes.field_body):
                f['classes'].append('action')
            for f in node.traverse(nodes.field_name):
                f['classes'].append('action')
            self.sectionlevel += 1
        if self.builder.config.use_xmoslatex:
            node['classes'].append('latex_compact')
            if 'latex_compact' in node['classes']:
                for f in node.traverse(nodes.field_name):
                    f['classes'].append('latex_compact')
                self.body.append('\\begin{option}\n\n')
                #            exit(1)
#        self.body.append('\\begin{tabular}{ll}')
#        self.body.append('\\begin{quote}\\begin{description}\n')
        pass
    def depart_field_list(self, node):
       if 'actions' in node['classes']:
           self.sectionlevel -= 1
       if self.builder.config.use_xmoslatex:
            if 'latex_compact' in node['classes']:
                self.body.append('\\end{option}\n\\vspace{-3mm}\n\n')

#            self.body.append('\\end{actions}\n\n')
#        self.body.append('\\end{description}\\end{quote}\n')
#        self.body.append('\\end{tabular} \n \n')
       pass

    def visit_field(self, node):
#        if 'action' in node['classes']:
#            self.body.append('\\item{')
#        self.body.append('\n\n\\textbf{')
#        self.body.append('abc ')
#        self.context.append('}')
        pass

    def depart_field(self, node):
#        if 'action' in node['classes']:
#            self.body.append('}\n\n')
#        self.body.append('}\n\n')
        pass


    def visit_field_name(self, node):
#        print self.sectionlevel
        if 'latex_compact' in node['classes']:
            self.body.append('\\item[')
        elif 'action' in node['classes']:
            if self.sectionlevel == 2:
                self.body.append('\\vspace{\\baselineskip}\n')
            self.body.append('\\%s*{'%self.sectionnames[self.sectionlevel+1])
        else:
            self.body.append('\\textbf{')

    def depart_field_name(self, node):
        if 'latex_compact' in node['classes']:
            self.body.append(']')

        elif 'action' in node['classes']:
            if self.sectionlevel == 2:
                self.body.append('}\n')
                self.body.append('\\vspace{-\\baselineskip}\n')
            else:
                self.body.append(':}\n')

        else:
            self.body.append(':}')
#        self.body.append('}\n\n')
        pass
        
        
#    visit_field_name = visit_term
#    depart_field_name = depart_term

    visit_field_body = visit_definition
    def depart_field_body(self,node):
        self.depart_definition(node)
#        self.body.append('\\\\ \n')

    def visit_paragraph(self, node):
#        if isinstance(node.parent,nodes.admonition):
#            print "ADM"
        self.para_icons = []
        self.para_inserts = []
        self.para_icon_insert_point = len(self.body)
        if not isinstance(node.parent, nodes.entry):
            self.body.append('\n')
        else:
            self.body.append('')


    def depart_paragraph(self, node):

        if 'windows' in node['classes']:
            self.para_inserts.append('\\windowsmargin')

        if 'mac' in node['classes']:
            self.para_inserts.append('\\macmargin')

        if 'linux' in node['classes']:
            self.para_inserts.append('\\linuxmargin')

        for i in range(self.para_icon_insert_point,len(self.body)):
            try:
                pre = self.body[i][-1]
                post = self.body[i+2][0]
                mid = self.body[i+1][0:5]
            except:
                continue

            if pre == '`' and post == '`' and mid == '\\verb':
                self.body[i+2] = '\'' + self.body[i+2][1:]

        icon_str = ''

        for m in node['margin_items']:
            icon_str += m+' '
        pos = self.para_icon_insert_point

        for i in range(pos, len(self.body)):
            if self.body[i] == 'ihjsqueezeihj':
                self.body[i-1] = self.body[i-1].rstrip()
                self.body[i] = ''
                self.body[i+1] = self.body[i+1].lstrip()

        first = self.body[pos+1]
        n = len(first) - len(first.lstrip())
        n = string.find(first,' ',n)
        if self.para_icons:
            if len(self.para_icons) == 2:
                icon_str += "\\doubleiconmargin{2}{%s}{%s}" % (self.para_icons[0],
                                                               self.para_icons[1])
            else:
                for icon in self.para_icons:
                    icon_str += '\\iconmargin{2}{%s} ' % icon
#        icon_str += ' '
        icon_str += ' '.join(self.para_inserts)
        self.body[pos+1] = first[:n] + icon_str + first[n:]
#        self.body = self.body[:pos] + ' gg ' + self.body[pos:]
        if not isinstance(node.parent, nodes.entry):
            self.body.append('\n')
        self.para_icons = None

    def visit_centered(self, node):
        self.body.append('\n\\begin{center}')
    def depart_centered(self, node):
        self.body.append('\n\\end{center}')

    def visit_hlist(self, node):
        # for now, we don't support a more compact list format
        # don't add individual itemize environments, but one for all columns
        self.compact_list += 1
        self.body.append('\\begin{itemize}\\setlength{\\itemsep}{0pt}'
                         '\\setlength{\\parskip}{0pt}\n')
    def depart_hlist(self, node):
        self.compact_list -= 1
        self.body.append('\\end{itemize}\n')

    def visit_hlistcol(self, node):
        pass
    def depart_hlistcol(self, node):
        pass

    def latex_image_length(self, width_str):
        match = re.match('(\d*\.?\d*)\s*(\S*)', width_str)
        if not match:
            # fallback
            return width_str
        res = width_str
        amount, unit = match.groups()[:2]
        if not unit or unit == "px":
            # pixels: let LaTeX alone
            return None
        elif unit == "%":
            res = "%.3f\\linewidth" % (float(amount) / 100.0)
        return res

    def is_inline(self, node):
        """Check whether a node represents an inline element."""
        return isinstance(node.parent, nodes.TextElement)

    def visit_image(self, node):
        attrs = node.attributes
        if 'iconmargin' in node['classes']:
            print node['uri']
            if re.match('.*windowsmargin\.png',node['uri']):
                self.para_inserts.append('\\windowsmargin')
            elif re.match('.*linuxmargin\.png',node['uri']):
                self.para_inserts.append('\\linuxmargin')
            elif re.match('.*macmargin\.png',node['uri']):
                self.para_inserts.append('\\macmargin')
            else:
                self.para_icons.append(node['uri'])
            return
        pre = []                        # in reverse order
        post = []
#        include_graphics_options = []
        if hasattr(self, 'include_graphics_options'):
            include_graphics_options = self.include_graphics_options
        else:
            include_graphics_options = []
        is_inline = self.is_inline(node)
        if attrs.has_key('scale'):
            # Could also be done with ``scale`` option to
            # ``\includegraphics``; doing it this way for consistency.
            pre.append('\\scalebox{%f}{' % (attrs['scale'] / 100.0,))
            post.append('}')
        if attrs.has_key('width'):
            w = self.latex_image_length(attrs['width'])
            if w:
                include_graphics_options.append('width=%s' % w)
        if attrs.has_key('height'):
            h = self.latex_image_length(attrs['height'])
            if h:
                include_graphics_options.append('height=%s' % h)
        if attrs.has_key('align'):
            align_prepost = {
                # By default latex aligns the top of an image.
                (1, 'top'): ('', ''),
                (1, 'middle'): ('\\raisebox{-0.5\\height}{', '}'),
                (1, 'bottom'): ('\\raisebox{-\\height}{', '}'),
                (0, 'center'): ('{\\hfill', '\\hfill}'),
                # These 2 don't exactly do the right thing.  The image should
                # be floated alongside the paragraph.  See
                # http://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
                (0, 'left'): ('{', '\\hfill}'),
                (0, 'right'): ('{\\hfill', '}'),}
            try:
                pre.append(align_prepost[is_inline, attrs['align']][0])
                post.append(align_prepost[is_inline, attrs['align']][1])
            except KeyError:
                pass
        if is_inline:
            pre.append('\\raisebox{-1mm}{')
            post.append('}')
        if not is_inline:
            pre.append('\n')
            post.append('\n')
        pre.reverse()
        if node['uri'] in self.builder.images:
            uri = self.builder.images[node['uri']]
        else:
            # missing image!
            if self.ignore_missing_images:
                return
            uri = node['uri']
        if uri.find('://') != -1:
            # ignore remote images
            return
        self.body.extend(pre)
        options = ''
        if include_graphics_options:
            options = '[%s]' % ','.join(include_graphics_options)
        self.body.append('\\includegraphics%s{%s}' % (options, uri))
        self.body.extend(post)
        self.include_graphics_options=[]
    def depart_image(self, node):
        pass

    def visit_figure(self, node):
        if self.builder.config.use_sidecaption:
            cap = ""
            for c in node.traverse(nodes.caption):
                cap = c[0]
            node['align'] = 'left'
            self.body.append('\\begin{figure}[H]\n')
            if self.fullwidth:
                self.body.append(u'\n\\begin{fullwidth}')
            self.body.append('\\begin{sidecaption}{%s}\n' % cap)

            end = '\\end{sidecaption}'
            if self.fullwidth:
                end += '\n\\end{fullwidth}'
            end += '\\end{figure}\n'
            self.context.append(end)
            if node.has_key('width'):
                node[0]['width'] = node['width']
            return
        ids = ''
        for id in self.next_figure_ids:
            ids += self.hypertarget(id, anchor=False)
        self.next_figure_ids.clear()
        if not node.has_key('width'):
            node['width'] = '100%'
        if node.has_key('width') and node.get('align', '') in ('left', 'right'):
            self.body.append('\\begin{wrapfigure}{%s}{%s}\n\\centering' %
                             (node['align'] == 'right' and 'r' or 'l',
                              node['width']))
            self.context.append(ids + '\\end{wrapfigure}\n')
        else:
            if (not node.attributes.has_key('align') or
                node.attributes['align'] == 'center'):
                # centering does not add vertical space like center.
                align = '\n\\centering'
                align_end = ''
            else:
                # TODO non vertical space for other alignments.
                align = '\\begin{flush%s}' % node.attributes['align']
                align_end = '\\end{flush%s}' % node.attributes['align']
            self.body.append('\\begin{figure}[H]%s\n' % align)
            if self.fullwidth:
                self.body.append(u'\n\\begin{fullwidth}')
#            if any(isinstance(child, nodes.caption) for child in node):
#                self.body.append('\\capstart\n')
            attrs = node.attributes
            self.include_graphics_options=[]
            if attrs.has_key('width'):
                w = self.latex_image_length(attrs['width'])
                if w:
                    self.include_graphics_options.append('width=%s' % w)
            fw_end = ''
            if self.fullwidth:
                fw_end = '\n\\end{fullwidth}'
            self.context.append(ids + align_end + fw_end + '\\end{figure}\n')

    def depart_figure(self, node):
        self.body.append(self.context.pop())

    def visit_caption(self, node):
        if self.builder.config.use_sidecaption:
            raise nodes.SkipNode
        else:
            self.body.append('\\caption{')

    def depart_caption(self, node):
        if not self.builder.config.use_sidecaption:
            self.body.append('}')

    def visit_legend(self, node):
        self.body.append('{\\small ')

    def depart_legend(self, node):
        self.body.append('}')

    def visit_admonition(self, node):
#        self.body.append('\n\\begin{notice}{note}')
        self.body.append('\n\na \warnmargin ')
    def depart_admonition(self, node):
#        self.body.append('\\end{notice}\n')
        pass



    def _make_visit_admonition(name):
        def visit_admonition(self, node):
            if self.builder.config.use_xmoslatex:
#                print node
                for p in node.traverse(nodes.paragraph):
                    p['margin_items'].append("\%smargin" % xmoslatex_admonitionlabels[name])
                    break
#                self.body.append('\n\n \\ \\hspace{-0.35cm} \%smarginraise '%xmoslatex_admonitionlabels[name])
            else:
                self.body.append(u'\n\n\\textbf{%s}: ' %
                                 (admonitionlabels[name]))
        return visit_admonition

    def _depart_named_admonition(self, node):
#        if not self.builder.config.use_xmoslatex:
#            self.body.append('\\end{notice}\n')
        pass

    visit_attention = _make_visit_admonition('attention')
    depart_attention = _depart_named_admonition
    visit_caution = _make_visit_admonition('caution')
    depart_caution = _depart_named_admonition
    visit_danger = _make_visit_admonition('danger')
    depart_danger = _depart_named_admonition
    visit_error = _make_visit_admonition('error')
    depart_error = _depart_named_admonition
    visit_hint = _make_visit_admonition('hint')
    depart_hint = _depart_named_admonition
    visit_important = _make_visit_admonition('important')
    depart_important = _depart_named_admonition
    visit_note = _make_visit_admonition('note')
    depart_note = _depart_named_admonition
    visit_tip = _make_visit_admonition('tip')
    depart_tip = _depart_named_admonition
    visit_warning = _make_visit_admonition('warning')
    depart_warning = _depart_named_admonition

    visit_newinxc = _make_visit_admonition('newinxc')
    depart_newinxc = _depart_named_admonition

    def visit_versionmodified(self, node):
        intro = versionlabels[node['type']] % node['version']
        if node.children:
            intro += ': '
        else:
            intro += '.'
        self.body.append(intro)
    def depart_versionmodified(self, node):
        pass

    def visit_target(self, node):
        def add_target(id):
            # indexing uses standard LaTeX index markup, so the targets
            # will be generated differently
            if id.startswith('index-'):
                return
            # do not generate \phantomsection in \section{}
            anchor = not self.in_title
            self.body.append(self.hypertarget(id, anchor=anchor))

        # postpone the labels until after the sectioning command
        parindex = node.parent.index(node)
        try:
            try:
                next = node.parent[parindex+1]
            except IndexError:
                # last node in parent, look at next after parent
                # (for section of equal level)
                next = node.parent.parent[node.parent.parent.index(node.parent)]
            if isinstance(next, nodes.section):
                if node.get('refid'):
                    self.next_section_ids.add(node['refid'])
                self.next_section_ids.update(node['ids'])
                return
            elif isinstance(next, nodes.figure):
                # labels for figures go in the figure body, not before
                if node.get('refid'):
                    self.next_figure_ids.add(node['refid'])
                self.next_figure_ids.update(node['ids'])
                return
            elif isinstance(next, nodes.table):
                # same for tables, but only if they have a caption
                for n in node:
                    if isinstance(n, nodes.title):
                        if node.get('refid'):
                            self.next_table_ids.add(node['refid'])
                        self.next_table_ids.update(node['ids'])
                        return
        except IndexError:
            pass
        if 'refuri' in node:
            return
        if node.get('refid'):
            add_target(node['refid'])
        for id in node['ids']:
            add_target(id)
    def depart_target(self, node):
        pass

    def visit_attribution(self, node):
        self.body.append('\n\\begin{flushright}\n')
        self.body.append('---')
    def depart_attribution(self, node):
        self.body.append('\n\\end{flushright}\n')

    def visit_index(self, node, scre=re.compile(r';\s*')):
        entries = node['entries']
        for type, string, tid, _ in entries:
            if type == 'single':
                self.body.append(r'\index{%s}' %
                                 scre.sub('!', self.encode(string)))
            elif type == 'pair':
                parts = tuple(self.encode(x.strip())
                              for x in string.split(';', 1))
                try:
                    self.body.append(r'\indexii{%s}{%s}' % parts)
                except TypeError:
                    self.builder.warn('invalid pair index entry %r' % string)
            elif type == 'triple':
                parts = tuple(self.encode(x.strip())
                              for x in string.split(';', 2))
                try:
                    self.body.append(r'\indexiii{%s}{%s}{%s}' % parts)
                except TypeError:
                    self.builder.warn('invalid triple index entry %r' % string)
            else:
                self.builder.warn('unknown index entry type %s found' % type)
        raise nodes.SkipNode

    def visit_raw(self, node):
        if 'latex' in node.get('format', '').split():
            self.body.append(node.astext())
        raise nodes.SkipNode

    def visit_reference(self, node):
        uri = node.get('refuri', '')
        if not uri and node.get('refid'):
            uri = '%' + self.curfilestack[-1] + '#' + node['refid']
        if self.in_title or not uri:
            self.context.append('')
        elif uri.startswith('mailto:') or uri.startswith('http:') or \
                 uri.startswith('https:') or uri.startswith('ftp:') or \
                 uri.startswith('/'):

            if uri.startswith('/'):
                uri = 'http://www.xmos.com'+uri

            if node.astext() == uri:
                if isinstance(node.parent,nodes.paragraph) and len(node.parent)==2:
                    self.body.append('\\triangleurl{%s}' % self.encode_uri(uri))
                else:
                    self.body.append('\\xurl{%s}' % self.encode_uri(uri))
                raise nodes.SkipNode
            else:
                self.body.append('\\href{%s}{' % self.encode_uri(uri))
            # if configured, put the URL after the link
                if self.builder.config.latex_show_urls and \
                        node.astext() != uri:
                    if uri.startswith('mailto:'):
                        uri = uri[7:]
                    self.context.append('} (%s)' % self.encode_uri(uri))
                else:
                    self.context.append('}')
        elif uri.startswith('#'):
            # references to labels in the same document
            id = self.curfilestack[-1] + ':' + uri[1:]
            self.body.append(self.hyperlink(id))
            if self.builder.config.latex_show_pagerefs:
                self.context.append('}} (%s)' % self.hyperpageref(id))
            else:
                self.context.append('}}')
        elif uri.startswith('%'):
            # references to documents or labels inside documents
            hashindex = uri.find('#')
            if hashindex == -1:
                # reference to the document
                id = uri[1:] + '::doc'
            else:
                # reference to a label
                id = uri[1:].replace('#', ':')
            self.body.append(self.hyperlink(id))
            if len(node) and hasattr(node[0], 'attributes') and \
                   'std-term' in node[0].get('classes', []):
                # don't add a pageref for glossary terms
                self.context.append('}}')
            else:
                if self.builder.config.latex_show_pagerefs:
                    self.context.append('}} (%s)' % self.hyperpageref(id))
                else:
                    self.context.append('}}')
        elif uri.startswith('@token'):
            if self.in_production_list:
                self.body.append('\\token{')
            else:
                self.body.append('\\grammartoken{')
            self.context.append('}')
        else:
            self.builder.warn(
                'unusable reference target found: %s' % uri,
                '%s:%s' % (self.builder.env.doc2path(self.curfilestack[-1]),
                           node.line or ''))
            self.context.append('')
        self.in_reference = True
    def depart_reference(self, node):
        self.in_reference = False
        self.body.append(self.context.pop())

    def visit_download_reference(self, node):
        pass
    def depart_download_reference(self, node):
        pass

    def visit_pending_xref(self, node):
        pass
    def depart_pending_xref(self, node):
        pass

    def visit_emphasis(self, node):
        if hasattr(self,'no_emph') and self.no_emph == 1:
            self.body.append('\\begin{comment}')
        elif not isinstance(node.parent, addnodes.desc_parameter):
            self.body.append(r'\emph{')
    def depart_emphasis(self, node):
        if hasattr(self,'no_emph') and self.no_emph == 1:
            self.no_emph = 0
            self.body.append('\\end{comment}\n')
        elif not isinstance(node.parent, addnodes.desc_parameter):
            self.body.append('}')

    def visit_literal_emphasis(self, node):
        self.body.append(r'\emph{\texttt{')
        self.no_contractions += 1
    def depart_literal_emphasis(self, node):
        self.body.append('}}')
        self.no_contractions -= 1

    def visit_strong(self, node):
        if self.builder.config.use_xmoslatex:
            if str(node[0]) == 'Enum Values:':
                node.parent.parent[1]['classes'].append('skip')
                self.body.append('This type has the following values:\n')
                raise nodes.SkipNode
            if str(node[0]) == 'Structure Members:':
                self.body.append('This structure has the following members:\n')
                raise nodes.SkipNode

        self.body.append(r'\textbf{')
    def depart_strong(self, node):
        self.body.append('}')

    def visit_abbreviation(self, node):
        abbr = node.astext()
        self.body.append(r'\textsc{')
        # spell out the explanation once
        if node.hasattr('explanation') and abbr not in self.handled_abbrs:
            self.context.append('} (%s)' % self.encode(node['explanation']))
            self.handled_abbrs.add(abbr)
        else:
            self.context.append('}')
    def depart_abbreviation(self, node):
        self.body.append(self.context.pop())

    def visit_title_reference(self, node):
        self.body.append(r'\emph{')
    def depart_title_reference(self, node):
        self.body.append('}')

    def visit_citation(self, node):
        # TODO maybe use cite bibitems
        self.bibitems.append(['', '', ''])  # [citeid, citetext, docname]
        self.context.append(len(self.body))
    def depart_citation(self, node):
        size = self.context.pop()
        text = ''.join(self.body[size:])
        del self.body[size:]
        # remove first word which is duplicated citation name
        self.bibitems[-1][1] = ' '.join(str.split(str(text),'\n')[1:])
#       print str.split(str(text),' ')
#       self.bibitems[-1][1] = text
        bi = self.bibitems[-1]
        target = self.hypertarget(bi[2] + ':' + bi[0].lower(),
                                  withdoc=False)
        self.body.append(u'\n%s\n[%s] \\raggedright {%s}\n' %
                         (target,bi[0], bi[1]))

    def visit_citation_reference(self, node):
        # This is currently never encountered, since citation_reference nodes
        # are already replaced by pending_xref nodes in the environment.
        self.body.append('\\cite{%s}' % self.idescape(node.astext()))
        raise nodes.SkipNode

    def visit_literal(self, node):
        self.no_contractions += 1
        content = self.encode(node.astext().strip())
        self.no_contractions -= 1
        if self.in_title:
            self.body.append(r'\texttt{%s}' % content)
        elif node.has_key('role') and node['role'] == 'samp':
            self.body.append(r'\samp{%s}' % content)
        elif self.in_footnote or self.in_reference or self.in_subscript:
            self.body.append(r'\code{%s}' % content)
        else:
            text = node.astext().strip()
            text = text.replace(' %','` \\texttt{\\ihjkel}\\verb`')
            text = text.replace('%','`\\texttt{\\%}\\verb`')
            text = text.replace('ihjkel','%')

            self.body.append('\\verb`%s`' % text)
        raise nodes.SkipNode

    def visit_footnote_reference(self, node):
        num = node.astext().strip()
        try:
            footnode, used = self.footnotestack[-1][num]
        except (KeyError, IndexError):
            raise nodes.SkipNode
        # if a footnote has been inserted once, it shouldn't be repeated
        # by the next reference
        if used:
            self.body.append('\\footnotemark[%s]' % num)
        else:
            footnode.walkabout(self)
            self.footnotestack[-1][num][1] = True
        raise nodes.SkipChildren
    def depart_footnote_reference(self, node):
        pass

    def visit_literal_block(self, node):
        self.verbatim = ''

    def depart_literal_block(self, node):
        code = self.verbatim.rstrip('\n')
        lang = self.hlsettingstack[-1][0]
        linenos = code.count('\n') >= self.hlsettingstack[-1][1] - 1
        if node.has_key('language'):
            # code-block directives
            lang = node['language']
        if node.has_key('linenos'):
            linenos = node['linenos']

#        print code
#        hlcode = self.highlighter.highlight_block(code, lang, linenos)
#        print hlcode
#        hlcode = '\begin{Verbatim}\n' + code + '\n\end{Verbatim}\n'
        hlcode = '\\begin{lstlisting}[resetmargins=true]\n' + code
        # workaround for Unicode issue
        hlcode = hlcode.replace(u'€', u'@texteuro[]')
        # must use original Verbatim environment and "tabular" environment
        if self.table:
            hlcode = hlcode.replace('\\begin{Verbatim}',
                                    '\\begin{OriginalVerbatim}')
            self.table.has_verbatim = True
        else:
            # hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=\\\\\\{\\}]',
            #                         '\\begin{SaveVerbatim}[commandchars=\\\\\\{\\}]{savedenv}')
            # hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=@\\[\\]]',
            #                         '\\begin{SaveVerbatim}[commandchars=@\\[\\]]{savedenv}')

            hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=\\\\\\{\\}]',
                                    '\\begin{lstlisting}')
            hlcode = hlcode.replace('\\begin{Verbatim}[commandchars=@\\[\\]]',
                                    '\\begin{lstlisting}}')
#                                    '\begin{Verbatim}[frame=lines,')
#                                    '\\begin{shaded}\n\\topsep=0ex\\relax\n\\begin{Verbatim}[frame=lines,')
                           
            pass
        # get consistent trailer
#        hlcode = hlcode.rstrip()[:-14] # strip \end{Verbatim}
        hlcode = hlcode.rstrip() + '\n'
#        self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\\end{shaded}\n' %  (self.table and 'Original' or ''))
        if self.table:
            self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\n' %  (self.table and 'Original' or ''))
        else:
#            self.body.append('\n\\vspace{-0.5cm}\n' + hlcode + '\\end{%sVerbatim}\n\n' %  (self.table and 'Original' or ''))

            if self.builder.config.tiny_verbatim:
                tinyv = '\\tiny'
            else:
                tinyv = '\\small'

            self.body.append('\n' + hlcode + '\\end{lstlisting}')
#            self.body.append('\n\\vspace{0.25\\baselineskip}\n' + hlcode + '\\end{SaveVerbatim}\n\\colorbox{lightgrey}{\\parbox{0.98\\textwidth}{%s \\BUseVerbatim{savedenv} \\normalsize }}\n\n\\vspace{0.25\\baselineskip}\n' % tinyv)
        self.verbatim = None
    visit_doctest_block = visit_literal_block
    depart_doctest_block = depart_literal_block

    def visit_line_block(self, node):
        """line-block:
        * whitespace (including linebreaks) is significant
        * inline markup is supported.
        * serif typeface
        """
        self.body.append('{\\raggedright{}')
        self.literal_whitespace += 1
    def depart_line_block(self, node):
        self.literal_whitespace -= 1
        # remove the last \\
        del self.body[-1]
        self.body.append('}\n')

    def visit_line(self, node):
        self._line_start = len(self.body)
    def depart_line(self, node):
        if self._line_start == len(self.body):
            # no output in this line -- add a nonbreaking space, else the
            # \\ command will give an error
            self.body.append('~')
        if self.table is not None:
            self.body.append('\\newline\n')
        else:
            self.body.append('\\\\\n')

    def visit_block_quote(self, node):
        # If the block quote contains a single object and that object
        # is a list, then generate a list not a block quote.
        # This lets us indent lists.
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            #if 'commentary' in node['classes']:
            #                self.body.append('\\begin{commentary}\n')
            if not 'skip' in node['classes']:
                #if self.builder.config.use_xmoslatex:
                #   self.body.append('\\vspace{-3mm}\n')
                #self.body.append('\\begin{quote}\n')
                self.body.append('\\begin{indentation}{\\forceindentlen}{0mm}')

    def depart_block_quote(self, node):
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            #if 'commentary' in node['classes']:
            #    self.body.append('\\end{commentary}\n')
            if not 'skip' in node['classes']:
                self.body.append('\\end{indentation}')
                #self.body.append('\\end{quote}\n')
                #if self.builder.config.use_xmoslatex:
                #    self.body.append('\\vspace{-3mm}\n')

    # option node handling copied from docutils' latex writer

    def visit_option(self, node):
        if self.context[-1]:
            # this is not the first option
            self.body.append(', ')
    def depart_option(self, node):
        # flag that the first option is done.
        self.context[-1] += 1

    def visit_option_argument(self, node):
        """The delimiter betweeen an option and its argument."""
        self.body.append(node.get('delimiter', ' '))
    def depart_option_argument(self, node):
        pass

    def visit_option_group(self, node):
        self.body.append('\\item [')
        # flag for first option
        self.context.append(0)
    def depart_option_group(self, node):
        self.context.pop() # the flag
        self.body.append('] ')

    def visit_option_list(self, node):
        self.body.append('\\begin{optionlist}{3cm}\n')
    def depart_option_list(self, node):
        self.body.append('\\end{optionlist}\n')

    def visit_option_list_item(self, node):
        pass
    def depart_option_list_item(self, node):
        pass

    def visit_option_string(self, node):
        ostring = node.astext()
        self.no_contractions += 1
        self.body.append(self.encode(ostring))
        self.no_contractions -= 1
        raise nodes.SkipNode

    def visit_description(self, node):
        self.body.append(' ')
    def depart_description(self, node):
        pass

    def visit_superscript(self, node):
        self.body[-1] = self.body[-1].rstrip()
        self.body.append('$^{\\text{')
    def depart_superscript(self, node):
        self.body.append('}}$')

    def visit_subscript(self, node):
        self.body[-1] = self.body[-1].rstrip()
        self.body.append('$_{\\text{')
        self.in_subscript = True

    def depart_subscript(self, node):
        self.body.append('}}$')
        self.in_subscript = False

    def visit_substitution_definition(self, node):
        raise nodes.SkipNode

    def visit_substitution_reference(self, node):
        raise nodes.SkipNode

    def visit_inline(self, node):
        classes = node.get('classes', [])
        if 'ebnf' in classes:
            self.body.append('\\emph{')
        elif 'tt' in classes:
            self.body.append('\\texttt{')
        elif 'cmd' in classes:
            if isinstance(node.parent,nodes.paragraph) and len(node.parent)==1 \
               and not (isinstance(node.parent.parent,nodes.list_item) and \
                        node.parent.parent[0] == node.parent):
                self.body.append('\\command{')
            else:
                self.body.append('\\texttt{')
#        self.body.append(r'\DUspan{%s}{' % ','.join(classes))

    def depart_inline(self, node):
        classes = node.get('classes', [])
        if 'ebnf' in classes:
            self.body.append('}')
        elif 'tt' in classes:
            self.body.append('}')
        elif 'cmd' in classes:
            self.body.append('}')

#        self.body.append('}')
        pass

    def visit_generated(self, node):
        pass
    def depart_generated(self, node):
        pass

    def visit_compound(self, node):
        pass
    def depart_compound(self, node):
        pass

    def visit_container(self, node):
        pass
    def depart_container(self, node):
        pass

    def visit_decoration(self, node):
        pass
    def depart_decoration(self, node):
        pass

    # docutils-generated elements that we don't support

    def visit_header(self, node):
        raise nodes.SkipNode

    def visit_footer(self, node):
        raise nodes.SkipNode

    def visit_docinfo(self, node):
        raise nodes.SkipNode

    # text handling

    def encode(self, text):
        text = unicode(text).translate(tex_escape_map)
        if self.literal_whitespace:
            # Insert a blank before the newline, to avoid
            # ! LaTeX Error: There's no line here to end.
            text = text.replace(u'\n', u'~\\\\\n').replace(u' ', u'~')
        if self.no_contractions:
            text = text.replace('--', u'-{-}')
        return text

    def encode_uri(self, text):
        # in \href, the tilde is allowed and must be represented literally
        return self.encode(text).replace('\\textasciitilde{}', '~')

    def visit_Text(self, node):
        if self.verbatim is not None:
            self.verbatim += node.astext()
        else:
            text = node.astext()

            text = self.encode(text)
            self.body.append(educate_quotes_latex(text))
#            self.body.append(text)

    def depart_Text(self, node):
        pass

    def visit_comment(self, node):
        raise nodes.SkipNode

    def visit_meta(self, node):
        # only valid for HTML
        raise nodes.SkipNode

    def visit_system_message(self, node):
        pass
    def depart_system_message(self, node):
        self.body.append('\n')

    def visit_math(self, node):
        self.body.append('$'+node['latex']+'$')

    def depart_math(self, node):
        pass
    

    def visit_displaymath(self, node):
        self.body.append('\n\n\\['+node['latex']+'\\]\n\n')

    def depart_displaymath(self, node):
        pass

    def unknown_visit(self, node):
        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)


    def visit_squeeze(self, node):
        self.body.append('SQQ')
        pass

    def depart_squeeze(self, node):
        pass

    def visit_ebnf(self, node):
        text= node[0].astext()

        # text = text.replace('\\','jkllslashjkll')
        # text = text.replace('{','\\{')
        # text = text.replace('}','\\}')
        # text = text.replace('%','\\%')
        # text = text.replace('&','\\&')
        # text = text.replace('&','\\&')
        # text = text.replace('jkllslashjkll','\\\\')



        lhs = ''
        for x in re.finditer(r'^(.*)::=', text):
            name = x.groups(0)[0].strip()
            if len(name) > len(lhs):
                lhs = name

        for x in re.finditer(r'[\n|^](.*)::=', text):
            name = x.groups(0)[0].strip()
            if len(name) > len(lhs):
                lhs = name

        text = text.replace('::=','!amp! !is! !amp!')
        text = text.replace('\n','!newline!')
        text = re.sub(r'!newline![ ]*\|','!newline! !amp! !choice! !amp!', text)
        text = re.sub(r'``(?P<txt>[^`]*)``','!token!\g<txt>!',text)
        text = re.sub(r'<(?P<txt>[^>]*)>\?','!opt!\g<txt>!',text)
        text = re.sub(r'<(?P<txt>[^>]*)>\*','!star!\g<txt>!',text)
        text = re.sub(r'<(?P<txt>[^>]*)>\+','!plus!\g<txt>!',text)
        text = self.encode(text)
        text = text.replace('!amp!','&')
        text = text.replace('!is!','\\is')
        text = text.replace('!newline!','\\\\ \n')
        text = text.replace('!choice!','\\choice')
        text = re.sub(r'!token!(?P<txt>[^!]*)!','\\\\token{\g<txt>}',text)
        text = re.sub(r'!opt!(?P<txt>[^!]*)!','\\\\ebnf{opt}{\g<txt>}',text)
        text = re.sub(r'!star!(?P<txt>[^!]*)!','\\\\ebnf{0}{\g<txt>}',text)
        text = re.sub(r'!plus!(?P<txt>[^!]*)!','\\\\ebnf{1}{\g<txt>}',text)
        self.body.append('\\begin{xcsyntax}{%s}\n'%lhs)
        self.body.append(text)
        self.body.append('\\end{xcsyntax}\n')
        raise nodes.SkipNode

    def depart_ebnf(self, node):
        pass
